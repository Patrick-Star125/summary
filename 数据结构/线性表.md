## 线性表

仅有一个开始节点和终端节点，每一个节点都有切仅有一个前驱和后继

### 顺序表

表内元素逻辑上相邻，物理地址上也相邻的一种线性表，因为这种特性，可以做到对元素的随机存取

与链表相比，顺序表易理解易存取，但是无法动态分配内存

不同的算法需要的内存空间不同，通常来讲顺序表比链表更加节省空间

一般的，对顺序表的操作有存、取、增、删

**实现：**这里演示一种简单的顺序表实现

``` c
#include <stdio.h>
#include <stdlib.h>

/*此处是顺序线性表数据结构定义*/
typedef int DataType;
struct seqList {//有3个数据成员
    int MAXNUM;//用于记录顺序线性表中能存放的最大元素个数的 整型 MAXNUM
    int curNum;//用于存放顺序线性表中数据元素的个数  整型  curNum
    DataType *element;//用于存放顺序线性表数据元素的连续空间的起始地址
};

typedef struct seqList *PseqList;

PseqList createNullList_seq(int m) {//创建一个空的顺序线性表，能存放的最大元素个数为 m
    //若m=0，则返回NULL
    if (m == 0)
        return NULL;

    PseqList head = (PseqList) malloc(sizeof(PseqList));
    head->MAXNUM = m;
    head->curNum = 0;
    head->element = (DataType *) malloc(sizeof(DataType));
    return head;
}

int isFullList_seq(PseqList L) {
    //判断顺序线性表是否已满，若已满，返回值为1，否则返回值为0
    if (L->curNum == L->MAXNUM) {
        return 1;
    } else {
        return 0;
    }
}


int insertP_seq(PseqList L, int p, int x) {// 在线性表L中下标为p的位置插入数据元素x，若下标p非法或线性表已满无法插入数据，返回0；插入成功返回值为1
    //如果线性表满了， 还需输"list is full"的提示
    //如果插入位置非法，需输出提示"position is illegel"
    if (p > L->MAXNUM - 1 || p < 0) {
        printf("position is illegel");
        return 0;
    }
    if (isFullList_seq(L)) {
        printf("list is full");
        return 0;
    }
    int i;
    for (i = L->curNum; i > p; i--) {
        L->element[i] = L->element[i - 1];
    }
    L->element[p] = x;
    L->curNum++;
    return 1;
}

int insertPre_seq(PseqList L, int p, int x) {
    // 在线性表L中下标为p的位置的前面插入数据元素x，若下标p非法或线性表已满无法插入数据，返回0；插入成功返回值为1
//提示：直接调用insertP函数实现即可
    return insertP_seq(L, p - 1, x);

}

int insertPost_seq(PseqList L, int p, int x) {
    // 在线性表L中下标为p的位置的后面插入数据元素x，若下标p非法或线性表已满无法插入数据，返回0；插入成功返回值为1
//提示：直接调用insertP函数实现即可
    return insertP_seq(L, p + 1, x);

}

void printList_seq(PseqList L) {//逐个输出线性表的元素，相邻的两个数据元素之间以一个空格为分隔符隔开
    int i;
    for (i = 0; i < L->curNum; i++) {
        printf("%d ", L->element[i]);
    }
}

int destroyList_seq(PseqList L) {
    //返回值为销毁的线性表中现有数据元素的个数，若待销毁的线性表不存在，则返回0
    if (L == NULL) {
        return 0;
    }

    int num = L->curNum;
    free(L->element);
    free(L);
    return num;
}

int locate_seq(PseqList L, int x) {//在顺序表L中查找给定值x首次出现的位置，若不存在给定值，则返回-1
    int i;
    for (i = 0; i < L->curNum; i++) {
        if ((L->element[i]) == x) return i;
    }

    return -1;
}

DataType locatePos_seq(PseqList L, int pos) {// 在顺序表L中查找指定位置pos处的数据元素，若位置非法，则返回第0个数据元素
    if (pos < 0 || pos >= L->MAXNUM) {
        return L->element[0];
    }

    return L->element[pos];
}

int deletePos_seq(PseqList L, int pos) {//在顺序表L中删除与下标pos处的数据元素，若pos非法，则返回-1；否则返回1
    int i;
    if (pos < 0 || pos >= L->MAXNUM) {
        return -1;
    }
    for (i = pos; i < (L->curNum - 1); i++) {
        L->element[i] = L->element[i + 1];
    }
    L->curNum -= 1;
    return 1;
}

int delete_seq(PseqList L, int x) {//在顺序表L中删除与参数x值相同的数据元素，返回删除数据元素的个数
    //可以使用之前已完成的操作
    int loc, bool_delete;
    int sum = 0;
    loc = locate_seq(L, x);
    while (loc != -1) {
        bool_delete = deletePos_seq(L, loc);
        if (bool_delete) {
            sum += 1;
        }
        loc = locate_seq(L, x);
    }
    return sum;
}


void replace_seq(PseqList L, int x, int y) {//将顺序表L中值为x的数据元素替换为y
    int loc;
    loc = locate_seq(L, x);
    while (loc != -1) {
        L->element[loc] = y;
        loc = locate_seq(L, x);
    }
}
```

### 链表

![普通链表](D:\Coder\Github\学习笔记\image\普通链表.png)

链表的内存地址分散的存储在各个地方，可以充分利用到零散的内存空间，但是由于需要存储节点的地址，通常来讲链表比顺序表更加耗费内存

**循环链表**

判断循环链表是否为空：

~~~c
if(list->next == list){
    pirntf("这是空循环");
}
~~~

**双向链表**

### 题目及其它