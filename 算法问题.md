## 01背包（物品不可分割）

因为选择较为简单，因此可以用动态规划解决，

![](http://1.14.100.228:8002/images/2022/04/15/20220415194857.png)



## 小数背包（物品可分割）

因为选择很多，无法用动态规划，反过来用贪心算法求近似解，贪心 策略 将物品按照性价比（单位重量价值）进行从大到小排序，将尽可能多的高性价比的物品装入背包，若将这种物品全部装入背包后，背包还有多余容量，则选择...用贪心算法解决一般背包问题 。 

C++代码

~~~c++
#include<stdio.h>
#include<algorithm>
#define MaxSize 1000
using namespace std;
typedef struct Node{
	int wight,value;
	double valueRate;
}node;
bool cmp(node a,node b){//自定义比较函数 
	return a.valueRate>b.valueRate;
}
double solve(int n,int C,node *arr){
	double ans=0;
	for(int i=0;i<n;i++){
		if(C>=arr[i].wight){//对价值率贪心，把能去满的物品直接取完 
			ans+=arr[i].value;//背包价值增加这个物品的价值 
			C-=arr[i].wight;//背包容量减少这个物品的重量 
		}
		else{//不能去完的物品，说明背包是最后容纳的某个物品的一部分 
			ans+=(double)C/arr[i].wight*arr[i].value;
			break;
		}
	}
	return ans;
}
int main(){
	int n,C;
	puts("输入物品个数n和背包容量C");
	scanf("%d%d",&n,&C);
	node arr[n];
	printf("输入%d个物品的重量\n",n);
	for(int i=0;i<n;i++)	scanf("%d",&arr[i].wight);
	printf("输入%d个物品的价值\n",n);
	for(int i=0;i<n;i++){
		scanf("%d",&arr[i].value);
		arr[i].valueRate=(double)arr[i].value/arr[i].wight;//算出价值率 
	}
	sort(arr,arr+n,cmp);//对价值率从高到低排序，实行贪心 
	double ans=solve(n,C,arr);
	printf("最终背包所装的最大价值为：%.1f",ans);
	return 0;
} 
~~~

## 矩阵链乘法

矩阵链乘法问题可以表述如下：给定n个矩阵构成的一个链（A1*A2*A3……*An），其中i=1,2,……n,矩阵Ai的维数为p(i-1)*p(i),对于乘积A1*A2*A3……*An以一种最小化标量乘法次数的方式进行加括号。



C++代码

~~~c++
//3d1-2 矩阵连乘 动态规划迭代实现  
//A1 30*35 A2 35*15 A3 15*5 A4 5*10 A5 10*20 A6 20*25  
//p[0-6]={30,35,15,5,10,20,25}  
#include "stdafx.h"  
#include <iostream>   
using namespace std;   

const int L = 7;  

int MatrixChain(int n,int **m,int **s,int *p);   
void Traceback(int i,int j,int **s);//构造最优解  

int main()  
{  
    int p[L]={30,35,15,5,10,20,25};  

    int **s = new int *[L];  
    int **m = new int *[L];  
    for(int i=0;i<L;i++)    
    {    
        s[i] = new int[L];  
        m[i] = new int[L];  
    }   

    cout<<"矩阵的最少计算次数为："<<MatrixChain(6,m,s,p)<<endl;  
    cout<<"矩阵最优计算次序为："<<endl;  
    Traceback(1,6,s);  
    return 0;  
}  

int MatrixChain(int n,int **m,int **s,int *p)  
{  
    for(int i=1; i<=n; i++)  
    {  
        m[i][i] = 0;  
    }  
    for(int r=2; r<=n; r++) //r为当前计算的链长（子问题规模）    
    {  
        for(int i=1; i<=n-r+1; i++)//n-r+1为最后一个r链的前边界    
        {  
            int j = i+r-1;//计算前边界为r，链长为r的链的后边界    

            m[i][j] = m[i+1][j] + p[i-1]*p[i]*p[j];//将链ij划分为A(i) * ( A[i+1:j] )   

            s[i][j] = i;  

            for(int k=i+1; k<j; k++)  
            {  
                //将链ij划分为( A[i:k] )* (A[k+1:j])     
                int t = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j];  
                if(t<m[i][j])  
                {  
                    m[i][j] = t;  
                    s[i][j] = k;  
                }  
            }  
        }  
    }  
    return m[1][L-1];  
}  

void Traceback(int i,int j,int **s)  
{  
    if(i==j) return;  
    Traceback(i,s[i][j],s);  
    Traceback(s[i][j]+1,j,s);  
    cout<<"Multiply A"<<i<<","<<s[i][j];  
    cout<<" and A"<<(s[i][j]+1)<<","<<j<<endl;  
} 
~~~



**暴力矩阵乘法伪代码**

~~~c
Function Solution(A, B, d, e, f)
    for i<-1 to d
        for j<-1 to f
            temp<-0
            for k<-1 to e
                temp<-temp+A[i][k]*B[k][j]
            C[i][j]=temp
    return C
~~~

