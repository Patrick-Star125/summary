# Main Structure

**历史**

![](http://pic.netpunk.space/images/2022/07/27/20220727173153.png)

**结构1**

![](http://pic.netpunk.space/images/2022/07/24/20220724132247.png)

**结构2**

![](http://pic.netpunk.space/images/2022/08/06/QQ20220803170005.png)

# 基础

## SQL

大致的内容在CMU15-445的课程笔记里面有，这里不过多赘述了，这里记一下在字节跳动青训营看到的以前没见过的东西

* 抽象语法树产生之后会进入一个分析阶段，之后生成**逻辑计划**

![](http://pic.netpunk.space/images/2022/07/27/OVXSB6Q6MA5SNWM2HEO.png)

* 查询优化器的意义在于对大数据集的处理效率

![img](http://pic.netpunk.space/images/2022/07/27/20220727163032.png)

* 在分布式系统中，由逻辑计划产生分布式可执行的物理计划

<img src="http://pic.netpunk.space/images/2022/07/27/20220727163119.png" style="zoom:67%;" />

* 物理计划被拆分为fragment，fragment就是主机执行计划的单位

![](http://pic.netpunk.space/images/2022/07/27/20220727163347.png)

* 市面上查询优化器的技术是可以分类的

<img src="http://pic.netpunk.space/images/2022/07/27/B0H5_KOUJWKDNPRXQOA3.png" style="zoom: 50%;" />

* RBO相关的一些知识

![](http://pic.netpunk.space/images/2022/07/27/20220727164212.png)

* CBO相关的一些知识

![](http://pic.netpunk.space/images/2022/07/27/20220727164408.png)

* 大部分时候用RBO就行，但是CBO一旦发挥作用就是绝杀
* 社区也有专门做SQL引擎的项目，比如Calcite

![](http://pic.netpunk.space/images/2022/07/27/7WVUAMAOFN72T9SZ3N.png)

* SQL引擎的前沿趋势

![](http://pic.netpunk.space/images/2022/07/27/20220727164531.png)

## OLAP引擎

**OLTP引擎**

OLTP（On-Line Transaction Processing）联机事务处理，它使分析人员能够迅速、一致、交互地从各个方面观察信息，以达到深入理解数据的目的。它具有FASMI(Fast Analysis of Shared Multidimensional Information)，即共享多维信息的快速分析的特征。主要应用是传统关系型数据库。OLTP系统强调的是内存效率，实时性比较高。Oracle、Redis、Hbase，可以发现，OLTP的应用基于内存效率，本身就非常快，所以没有OLTP计算引擎的概念（不单独成组件）

## Shuffle

# 流式引擎

## Flink架构

因为我对Flink的学习并不系统，也不能指望用两节课来学会，所以这里也是简单记一下

* 业内对大数据实时处理的要求导致Flink备受宠爱

![](http://pic.netpunk.space/images/2022/07/27/20220727174941.png)

* 关于不同阶段的流式计算引擎的对比，可以看出，Flink能够脱颖而出的原因就是它拥有许多很好的特性

![](http://pic.netpunk.space/images/2022/07/27/20220727174830.png)

* Flink最重要的特性

![](http://pic.netpunk.space/images/2022/07/27/20220727185200.png)

* Flink分层架构

![](http://pic.netpunk.space/images/2022/07/27/20220727190347.png)

其中，最重要的DAG Scheduler和Shuffle Service的作用分别是，执行DAG图并进行调度和主机之间传输流/批数据

* Flink总体架构。在一个Flink集群中，主要包含以下两个核心组件，

![](http://pic.netpunk.space/images/2022/07/28/20220728102136.png)

在整个Flink的系统中，这个两个组件进行核心的工作，体现在数据的处理过程上

![](http://pic.netpunk.space/images/2022/07/28/20220728104042.png)

* 具体的流程如下图所示

![](http://pic.netpunk.space/images/2022/07/28/20220728104455.png)

文字解释如下

![](http://pic.netpunk.space/images/2022/07/28/20220728104515.png)

* 一个实例，用java写的统计数据流中单词出现的次数

![](http://pic.netpunk.space/images/2022/07/28/20220728110159.png)

一个简单的Flink作业有三个阶段，一是Source，二是Transformation，三是Sink

如果加上并发度的概念，则如下图所示

<img src="http://pic.netpunk.space/images/2022/07/28/20220728110818.png" style="zoom: 67%;" />

为了更高效地分布式执行，Flink 会尽可能地将不同的operator链接( chain )在一起形成Task。这样每个Task 可以在一个线程中执行，内部叫做OperatorChain，如下图的source和map算子可以Chain在一起。

<img src="http://pic.netpunk.space/images/2022/07/28/20220728111122.png" style="zoom:67%;" />

上面也是这个Task的物理执行图，其中虚线框住的就是一个个SubTask，最后将上面的Task 调度到具体的TaskManager中的slot 中执行，一个Slot只能运行同一个task的SubTask

![](http://pic.netpunk.space/images/2022/07/28/20220728111627.png)

* 业内有不少要求流批一体的业务，但是传统的架构是流批分开，包括字节在内的大公司

![](http://pic.netpunk.space/images/2022/07/28/20220728151351.png)

![](http://pic.netpunk.space/images/2022/07/28/20220728151500.png)

* 如前面所述，在flink中提供了基本抽象，可以将有界数据集看作数据流来处理，只是需要对不同场景提供单独支持，我们需要一个更加灵活的调度策略

![](http://pic.netpunk.space/images/2022/07/28/20220728160029.png)

* 从scheduler层来看，在1.12之前的 Flink版本中，Flink支持以下两种调度模式

![](http://pic.netpunk.space/images/2022/07/28/20220728160430.png)

流：等待资源到位，全力处理

批：一边调整资源一边计算

* Blocking与PipeLine

![](http://pic.netpunk.space/images/2022/07/28/20220728161220.png)

在调度层用pipeline region的概念对流和批的事务处理进行了基本的抽象

* 从Shuffle Service来看，用来链接上下游数据交互的操作就是Shuffle，通常有两种实现

![](http://pic.netpunk.space/images/2022/07/28/20220728162533.png)

![](http://pic.netpunk.space/images/2022/07/28/20220728162735.png)

![](http://pic.netpunk.space/images/2022/07/28/20220728165142.png)

* 在flink有两种shuffle service

![](http://pic.netpunk.space/images/2022/07/28/20220728165024.png)

* 数据场景有三种，性能要求不同

![](http://pic.netpunk.space/images/2022/07/28/20220728165607.png)

![](http://pic.netpunk.space/images/2022/07/28/20220728165543.png)

* 批计算是流计算的特例，OLAP是一种特殊的批计算，flink做OLAP的优势

![](http://pic.netpunk.space/images/2022/07/28/20220728170105.png)

*   flink的OLAP挑战

![](http://pic.netpunk.space/images/2022/07/28/20220728170547.png)

* 用flink进行OLAP架构

![](http://pic.netpunk.space/images/2022/07/28/20220728193441.png)

* 总结

![](http://pic.netpunk.space/images/2022/07/28/20220728193959.png)

在字节内部，flink用来负责HTAP场景中AP查询部分，大大提升查询速度

![](http://pic.netpunk.space/images/2022/07/28/20220728194121.png)

最后，如下图所示

![](http://pic.netpunk.space/images/2022/07/28/20220728194303.png)

**还有一些思考的问题**

flink怎么用，有哪些用法？

flink的分层架构是怎样？

flink怎样支持流批一体？

flink怎样支持AP场景，有哪些问题，如何解决？

进一步的，流式计算框架如何支持AP场景，有哪些方面可以考虑？

## Flink与Exactly Once

在流式计算场景的低延时的要求下，安全也是不可忽视的一部分，要理解流式计算的安全问题，首先就要理解流式计算的数据模型特点。

* 数据的转换和处理框架如图所示

![](http://pic.netpunk.space/images/2022/07/30/20220730172016.png)

* 数据有以下来源和特点

![](http://pic.netpunk.space/images/2022/07/30/20220730172241.png)

* 最重要的是动态表的概念和SQL处理的模型，其中SQL在处理动态表时有**状态**的概念

![](http://pic.netpunk.space/images/2022/07/30/20220730172441.png)

* 流式计算过程中INSERT、UPDATE、DELETE操作都有各自的特点

![](http://pic.netpunk.space/images/2022/07/30/20220730172545.png)

* 因此，根据发生故障时，数据处理的粒度，将安全性分为三个等级

![](http://pic.netpunk.space/images/2022/07/30/QQ20220730165757.png)

* 一次简单的故障恢复可描述为下图所示

![](http://pic.netpunk.space/images/2022/07/30/20220730173629.png)

* 从算子的角度来看，快照恢复的时候可能出现数据未消费的情况

![](http://pic.netpunk.space/images/2022/07/31/QQ20220730175137.png)

* 分布式checkpoint算法，当数据源有多个时，算子之间的关系很复杂

![](http://pic.netpunk.space/images/2022/07/31/20220731152126.png)

* 过程二三如下图所示，可知状态制作和数据处理是解耦的，JM觉得状态是否完全保存

![](http://pic.netpunk.space/images/2022/07/31/20220731152253.png)

* 计算过程的Exactly Once由CheckPoint保证，所有数据都仅被消费一次

* sink算子对下游数据传输光靠CheckPoint不能保证Exactly Once，需要对sink，或者说对传输过程进行处理，这就是二阶段提交

![](http://pic.netpunk.space/images/2022/07/31/20220731153426.png)

* 在Flink中，二阶段提交和CheckPoint一起提供上下游的Exactly Once

![](http://pic.netpunk.space/images/2022/07/31/QQ20220731112341.png)

* 总结

![](http://pic.netpunk.space/images/2022/07/31/QQ20220731115707.png)

Flink中多个事务的异步快照制作和故障恢复过程具体是怎么样的？

## Flink与window计算

* 通过window计算能够提高流式计算的实时性，下图是之前学的和现在要学的总结

![](http://pic.netpunk.space/images/2022/08/02/20220802164732.png)

可以发现，我们学习了流式计算的基本概念和安全保障，但是真正核心的计算还没有涉及。对应的知识就是Window算子，我们要了解它的前因后果，并且学习它在Flink中如何表现

* 流式计算和批式计算的本质在数据实时性上，对业务来讲，本质上数据的实时性越高，价值越高。

![](http://pic.netpunk.space/images/2022/08/02/20220802170032.png)

* 把批计算处理时间间隔减小的困难不在于计算复杂度，而是批计算的任务时间长度都不定，从几分钟到几小时不等，因此批计算有批计算的应用场景

![](http://pic.netpunk.space/images/2022/08/02/20220802170224.png)

* 两个概念，处理时间和事件时间，处理时间多少会比事件时间晚一些，我们说的窗口是针对事件时间来表示的（这地方还有点模糊）

![](http://pic.netpunk.space/images/2022/08/02/20220802170945.png)

* 另一个重要概念，watermark：表示当前的机器时间，这是算子的可见时间标记，对算子来说这就是时间这一概念的来源

![](http://pic.netpunk.space/images/2022/08/02/20220802171154.png)

* watermark有两种实现

![](http://pic.netpunk.space/images/2022/08/02/20220802173907.png)

* watermark在算子中的作用原理，一般是取多个source的最小值

![](http://pic.netpunk.space/images/2022/08/02/QQ20220801103208.png)

* 有两种不同的watermark生成方法

![](http://pic.netpunk.space/images/2022/08/02/20220802174133.png)

* 数据断流和迟到数据问题

![](http://pic.netpunk.space/images/2022/08/02/20220802174233.png)

* Window算子分类和调用方法

![](http://pic.netpunk.space/images/2022/08/02/20220802174620.png)

* 滚动窗口、滑动窗口、会话窗口的形象特点

![](http://pic.netpunk.space/images/2022/08/02/20220802174800.png)

它们有各自的应用场景，都非常常见

* window对一些场景有特殊处理

![](http://pic.netpunk.space/images/2022/08/02/20220802183950.png)

* Window计算有两种类型

![](http://pic.netpunk.space/images/2022/08/02/20220802184133.png)

* EMIT操作减少了窗口计算的热点问题

![](http://pic.netpunk.space/images/2022/08/02/20220802184226.png)

* window计算同样有很多可以优化的点

![](http://pic.netpunk.space/images/2022/08/02/20220802184443.png)

* 在实际场景中一个很常用的优化方法是二阶段聚合

![](http://pic.netpunk.space/images/2022/08/02/20220802184533.png)

* 总结

![](http://pic.netpunk.space/images/2022/08/02/20220802184553.png)

# 批式引擎

## Spark架构

* Spark主要用于海量数据的离线处理

![](http://pic.netpunk.space/images/2022/08/06/QQ20220803170508.png)

* spark的进化历程（都是重要的概念）

![](http://pic.netpunk.space/images/2022/08/06/QQ20220803171109.png)

* spark生态

![](http://pic.netpunk.space/images/2022/08/06/QQ20220803171414.png)

* spark支持多语言（不知道为什么R也支持）

![](http://pic.netpunk.space/images/2022/08/06/QQ20220803171550.png)

* 关于spark的datasource，可以是内置的也可以实现**自定义**

![](http://pic.netpunk.space/images/2022/08/06/QQ20220803171615.png)

* spark代码的交互、编译和提交

![](http://pic.netpunk.space/images/2022/08/09/20220809113116.png)

* RDD基础概念

  ![](http://pic.netpunk.space/images/2022/08/04/20220804173246.png)

  * 可以容错的，并行执行的分布式数据集		
  * spark数据处理的基本单元
  * 五个特性
    * 每个RDD都有不同分区，不同分区运行在集群的不同节点上，每个分区都会被一个task处理，分区决定并行计算任务的数量，创建RDD的时候可以指定分区的数量，默认分区数的cpu个数
    * RDD给每个分区一个具体的function计算
    * RDD的每次转换都会形成一个新的RDD，每一个RDD都依赖于其它的RDD
    * 两种类型的分区函数，称为partitioner，分别是基于hash的基于range的（只针对KV数据分区）
    * 每个分区都会有一个优先的位置列表，存储每个partition的优先位置，针对partition的计算会将数据存储到优先的位置（移动计算）

* RDD从行为上看可以分为两类，Transform和Action，它们都既可以是内置的也可以是自定义的，只需实现对应的接口即可

![](http://pic.netpunk.space/images/2022/08/09/20220809113435.png)


* 宽依赖和窄依赖

![](http://pic.netpunk.space/images/2022/08/05/20220805153857.png)

这个概念的意义：结合RDD的执行逻辑和partition的行为，可以知道依赖是RDD执行最核心的概念，串联起执行阶段、Shuffle、故障恢复等等

* 最重要的是RDD结合宽窄依赖（stage概念）进行作业的过程

将一个分布式认为由宽依赖分为多个stage，其实也就是用是否shuffle来分段，如果不用shuffle，则数据一直在本地处理，还处于map或者reduce的阶段，此时一个stage内某个分区的所有计算都统称为一个task，而DAG作业过程的调度者

![](http://pic.netpunk.space/images/2022/08/09/QQ20220805154118.png)

* spark内存管理的构成和利用方式

内存有两大部分构成，分配给task

![](http://pic.netpunk.space/images/2022/08/09/20220809120609.png)

* shuffle操作也是RDD，由管理器统一调度，有他自己的接口

![](http://pic.netpunk.space/images/2022/08/09/20220809120801.png)

* shuffle数据处理过程，以文件为基础

![](http://pic.netpunk.space/images/2022/08/09/20220809120857.png)

* spark有一些自动优化的策略，非常好用，但是原理比较难

![](http://pic.netpunk.space/images/2022/08/09/QQ20220805163402.png)

* 代码生成：算子之间会有大量函数调用，增加运行消耗，生成代码实时编译运行将算子逻辑生成到一个函数里面，可大大增加运行效率，根据粒度不同，代码生成不同类型，它们之间没有互相包含的关系

![](http://pic.netpunk.space/images/2022/08/09/20220809121738.png)

* shuffleService也是限制计算性能瓶颈之一

![](http://pic.netpunk.space/images/2022/08/09/20220809121948.png)

* 从代码层面更好的利用cpu资源

![](http://pic.netpunk.space/images/2022/08/09/QQ20220806142806.png)

* 自动调参

<img src="http://pic.netpunk.space/images/2022/08/09/QQ20220806142906.png" style="zoom:67%;" />

* 优化思路

<img src="http://pic.netpunk.space/images/2022/08/09/QQ20220806142831.png" style="zoom:67%;" />



# 交互式处理引擎

## Presto



## ClickHouse



## Doris

























