## IO设备

I/O（Input/Output），即输入/输出是系统的重要组成部分，计算机通过IO存取设备，通过IO和外界交互。程序通过IO执行功能。因此IO与操作系统结合方式是系统是否高效的关键。首先我们需要了解系统IO架构是怎样的。

根据IO**数据的来源**不同，系统IO架构可分为三层，一是高速内存的IO流，二是高速设备如显卡、高速网卡的IO流，三是慢速设备如磁盘、U盘、键盘鼠标等IO流。现代IO架构也会有专门的芯片组和点对点互连用于加速IO操作，例如x86平台。下图展示了IO架构的传统模型和现代系统的IO架构。

<img src="http://1.14.100.228:8002/images/2022/03/10/20220311094452.png" style="zoom:80%;" />

而对于单个设备来说，包含两个部分，一是暴露给操作系统的接口，二是硬件的抽象内部结构。设备接口简化来讲可以分为三个寄存器，分别是状态寄存器、命令寄存器、数据寄存器。操作系统对设备的调用，也可以由这三个寄存器来抽象为以下过程。

<img src="http://1.14.100.228:8002/images/2022/03/10/20220311100432.png" style="zoom:80%;" />

通过轮询状态寄存器，我们能够实现设备的长期访问，但是我们也知道，很多情况下轮询总是低效的，因此我们可以用中断来代替轮询，具体的，操作系统可以发出一个请求，将调用进程置于睡眠状态，并将上下文切换到另一个任务，而不是重复轮询设备。因此，IO和计算可以重叠。

<img src="http://1.14.100.228:8002/images/2022/03/10/20220311100916.png" style="zoom:80%;" />

但中断并不总是最好的解决方案，一个设备执行任务非常快时第一个轮询通常会找到要完成任务的设备。在这种情况下使用中断实际上会降低系统的速度，并且中断的方法可能造成**活锁**的问题。所以如果不知道设备的速度，或者有时快，有时慢，最好使用一个混合轮询器，轮询一段时间后，如果设备还没有完成，就使用中断。这种分两阶段的方法可以两全其美。

并且中断是可以合并的，在这样的设置中，需要触发中断的设备首先要等待一段时间，然后才将中断发送给CPU。这样能够降低中断的总体开销。

当我们使用programmed IO（PIO）来操作大块数据进入设备时。CPU会忙于搬运数据，浪费很多CPU时间。解决方案就是我们所说的直接内存访问(DMA)。它本质上是系统中的一种非常特定的设备，它可以在不需要太多CPU干预的情况下协调设备和主存之间的传输。为了将数据传输到设备，操作系统将通过告诉DMA引擎数据在内存中的位置、复制多少数据以及将数据发送到哪个设备来编程。此时，操作系统完成了传输，可以继续进行其他工作。当DMA完成时，DMA控制器引发一个中断，这样OS就知道传输完成了。修改后的时间表。有DMA介入的CPU timpline如下图所示。

<img src="http://1.14.100.228:8002/images/2022/03/10/20220311101641.png" style="zoom:80%;" />

让我们再深入设备的内部，看看操作系统是怎么与设备直接交互的，具体来说，有两种方式。

第一种，也是最古老的方法(IBM大型机使用了多年)是使用显式的I/O指令。这些指令为操作系统指定了一种将数据发送到特定设备寄存器的方式。例如x86系统下的in和out指令，要将数据发送到一个设备，调用者指定一个包含数据的寄存器，以及一个指定设备名称的特定端口。

第二种方法称为内存映射I/O。使用这种方法，硬件使设备寄存器可用，就像它们是内存位置一样。为了访问一个特定的寄存器，操作系统发出一个加载(读)或存储(写)地址;然后硬件将加载/存储路由到设备而不是主存储器。也就是像访问内存一样访问设备。

这两种方法都没有很大的优势。内存映射方法很好，因为不需要新的指令来支持它，但这两种方法今天仍然在使用。

但是设备内部到底是如何呢，这要求我们继续讨论设备驱动的概念，这是操作系统能够与设备交互的最底层方式，任何与设备交互的细节都封装在里面。

通过Linux文件系统软件堆栈，我们可以了解这种抽象如何帮助操作系统的设计和实现。

<img src="http://1.14.100.228:8002/images/2022/03/10/20220311104126.png"  />

可以看到，文件系统(当然，上面的应用程序)完全不知道它使用的是哪个磁盘类;它只是向通用块层发出块读和写请求，通用块层将它们路由到适当的设备驱动程序，后者处理发出特定请求的细节。上面图还有一个Raw接口，它允许特殊的应用程序(如文件系统检查器，稍后[AD14]描述，或磁盘碎片整理工具)直接读写块，而不使用文件抽象。

上面看到的封装也有其缺点。例如，如果有一个设备具有许多特殊的功能，但是必须向内核的其他部分提供一个通用接口，那么这些特殊功能将不会被使用。例如，在带有SCSI设备的Linux中，有非常丰富的错误报告;因为其他块设备(如ATA/IDE)有更简单的错误处理，所有更高级别的软件曾经接收到的是通用EIO错误代码，因此更详细的错误消息就消失了。

因为任何插入系统的设备都需要设备驱动程序，随着时间的推移，它们已经占据了内核代码的很大比例。对Linux内核的研究表明，超过70%的操作系统代码存在于设备驱动程序中[C01];对于基于windows的系统，这个数字可能也相当高。因此，当人们告诉你操作系统有数百万行代码时，他们实际上是在说操作系统有数百万行设备驱动程序代码。当然，对于任何给定的安装，大多数代码可能都不是活动的。

我们以一个IDE驱动的实际例子来解释操作系统怎么通过驱动程序和设备交互，如下图所示。

<img src="http://1.14.100.228:8002/images/2022/03/10/20220311104443.png"  />

* ide_rw()：将一个请求排入队列，或者直接发送到磁盘
* ide_start_request()：向磁盘发出请求，用in和out指令来读写设备寄存器
* ide_wait_ready()：用于确保启动器就绪 
* ide_intr()：中断处理，发送切换进程信息

我们来做一个小结，这次学习了操作系统和设备架构和设备驱动程序，一个顶层设计，一个是底层原理。对于操作系统设备调用方式的优化，我们讨论了中断，对于CPU调度的优化，我们讨论了DMA。有关操作系统如何与设备交互，我们讨论了显式IO指令和内存映射两种方式，通过这一连串的方法，我们能够以以一种与设备无关的方式来构建操作系统的其余部分（这就是设备驱动程序的核心功能）。

## 磁盘驱动

想到操作系统的持久化，很多人首先想到的是文件系统，然而从硬件角度，持久化的基本是硬盘。因此，在构建文件系统之前，首先要里了解存储文件的磁盘是怎么驱动的。

硬盘的接口很简单，对于系统来说硬盘的存储空间是由一个个扇区（512 bytes）组成，每个扇区都能够读和写。这一个个扇区组成的列表就是硬盘的**地址空间。**对于硬盘空间有一个知名的假设，对于连续空间的读写是速度最快的读写操作，这种假设的根据我们在后面会提到。

我们首先了解一下机械硬盘的硬件组成，硬盘中最核心的部位是**盘片**，盘片是一个圆形的硬表面，通过诱导磁变化将数据持久地存储在上面。一个磁盘可以有一个或多个盘片；每个盘片有两面，每一面都被称为面。这些盘片通常由一些硬材料(如铝)制成，然后涂上一层薄薄的磁性层，使驱动器即使在断电时也能持久存储比特信息。

盘片都被绑在一起围绕着**主轴**，主轴与一个电机相连，电机以恒定的速度旋转盘片。转速通常以转速**每分钟(RPM)**来测量，典型的现代值在7,200RPM到15,000RPM范围内。数据以扇区的同心圆在每个表面进行编码；我们称这样一个同心圆为**轨道**。一个单一的表面包含成千上万的轨道，紧密地排列在一起，数百条轨道的宽度相当于一根头发。读写过程是由磁头来完成，驱动器的每个表面都有一个这样的磁头。磁盘头附着在单个磁盘臂上，该臂在表面移动，将磁盘头定位在所需的轨道上。

<img src="http://1.14.100.228:8002/images/2022/03/12/20220312221314.png" style="zoom:80%;" />

现代盘片下有数百万个轨道，了解了硬盘的物理模型后，我们看一个多轨盘片下的IO请求处理流程，如果磁头想要读写某个扇区的数据，会经历**变轨-旋转-传输**三个过程。通常来讲其中变轨开销很大，因为磁头要抬头-旋转-再低头。但是现代硬盘，变轨和旋转两个过程的开销可以做到几乎相同。

硬盘中各个结构还有一些其它特性，首先各个轨道并不是对称的，因为磁头的转动需要时间，一些倾斜可以做到变轨也能读取连续扇区。然后是外部轨道往往比内部轨道有更多的扇区，每个分区在每个轨道上有相同数量的扇区，外部区域比内部区域有更多扇区。最后，任何现代磁盘驱动器的一个重要部分是它的缓存，通常是8或16MB，例如，当从磁盘读取一个扇区时，驱动器可能决定读取该磁道上的所有扇区，并将它们缓存到内存中，这样做可以使驱动器快速响应对同一轨道的任何后续请求。还有一些其它非性能行为，例如，当数据还在内存里面，数据读写完成的报告就已经返回给系统了，这些在这里不表。

<img src="http://1.14.100.228:8002/images/2022/03/12/20220312221954.png" style="zoom:80%;" />

如何理解磁盘性能呢？我们提出IO性能的概念，其计算公式如下。

<img src="http://1.14.100.228:8002/images/2022/03/12/20220312222129.png" style="zoom:80%;" />

我们以两种情况下的IO请求来说明现代磁盘IO性能的到底是怎样的。两种IO分别是随机工作负载，即将少量(例如，4KB)的数据读取到磁盘上的随机位置，和顺序工作负载，即连续地从磁盘读取大量扇区，而不需要跳转。我们用两款不同定位的硬盘来分别进行实验。硬盘参数和实验结果如下。

<img src="http://1.14.100.228:8002/images/2022/03/12/20220312222703.png" style="zoom:80%;" />

可以看出在随机和顺序工作负载之间的性能存在巨大差异，Cheetah的差异接近200倍左右，Barracuda的差异超过300倍。由此可知，尽量大块的传输数据对读写速度提升帮助巨大。

IO请求在实际运行之前需要进行调度，具体的，给定一组I/O请求，**磁盘调度程序**检查这些请求并决定下一步调度哪个请求。由于我们可以很简单地猜测一个磁盘请求将花费多长时间，因此，磁盘调度器在其操作中将尝试遵循SJF(最短作业优先)的原则。

第一种尝试是SSTF（Shortest Seek Time First），SSTF根据跟踪对I/O请求队列进行排序，选择最近的跟踪上的请求先完成。例如下图的模型。看起来不错，但是SSTF有两个问题，第一个是操作系统无法看到硬盘内部信息，相反，它看到的是一个块数组，所以操作系统可以简单地实现最近邻块优先(NBF)，而不是SSTF, NBF调度接下来使用最近邻块地址的请求。第二个问题是starving，如果对于当前头部的位置有一个稳定的IO请求，那么其它所有的IO请求都会被完全无视。

针对这些问题有过一些SSTF的变体，如F-SCAN，S-SCAN等，但是这些都没有完全解决SSTF的问题，相反的，它们也忽视了旋转的开销。

第二种尝试是SPTF，它会“视情况而定”来选择先处理哪个扇区的读写，这取决于寻找的相对时间和旋转的相对时间。在现代磁盘上，查找和旋转基本上是同等开销的，这取决于具体的请求，SPTF重点解决了旋转的开销问题，但是似乎没有解决starving问题，这里我们要提出**IO请求的调度**这个概念。

磁盘调度在哪里执行?在旧的系统中，操作系统完成所有的调度，但是由于不清楚磁盘情况，操作系统实现SPTF这样的方法比较困难，而在现代系统中，磁盘可以容纳多个未完成的请求，并且具有复杂的内部调度器（可以精确地实现SPTF）。OS调度器通常选择它认为最好的几个请求(比如16个)，并将它们全部发送到磁盘。然后，磁盘利用其内部对磁头位置的了解和详细的轨道布局信息，以尽可能好的顺序(SPTF)为上述请求提供服务。由此，解决了starving问题。

<img src="http://1.14.100.228:8002/images/2022/03/12/20220312225340.png" style="zoom:80%;" />

关于磁盘调度器还有一些方面可以讲，磁盘调度器执行的另一个重要相关任务是I/O合并。例如，假设有一系列读取block 33、block 8、block 34的请求，调度器应该将block 33和block 34的请求合并成一个单独的两个block请求，从而降低开销。而系统在向磁盘发出I/O之前应该等待多长时间？对预期磁盘调度的研究表明，有时最好是等一下其它请求再发给磁盘（具体的原因我也不太懂）。

## 冗余磁盘阵列

我们介绍了硬盘的基本模型，理论上，我们总是对磁盘有**可靠性（reliable）**的要求。这要求硬盘有**备份**的功能，不光是备份，磁盘通过备份要有**检测故障**，的能力。另外，很多时候我们对**性能**有一定的要求，并且我们大多时候希望在实现以上要求的前提下能够保持可用存储空间尽量大。

基于以上要求，我们提出了Redundant Array of Inexpensive Disks（RAID）。通过RAID，系统能够将多个磁盘视作一个大的存储空间。通过这种抽象，RAID为系统提供了关键的**透明性**，使得不同的系统能够在不同配置的磁盘下正常工作。

**注：**向系统添加新功能的时候应当考虑是否可以透明的添加，而不需要对系统的其余部分进行更改，大大降低了部署的难度，可以说RAID这一性质已经隐喻了它的成功。

通过RAID串联起多个磁盘有三大好处，性能：多个同步磁盘可以加速IO时间，容量：存放更多大数据集，可靠性：允许单个硬盘丢失数据，这种分析方法在之后也会用到。一般的，RAID可以分为软件实现和硬件实现，我们主要讨论硬件实现，处于主板上的RAID很像一个小型电脑，拥有它自己的处理器，持久化RAM和所连接的磁盘，但是上面运行的并不是应用，而是专门的固件。

RAID内部处理IO的流程是，接收操作系统传输的逻辑IO请求后，由RAID转化为多个物理IO，同时在多个磁盘副本上进行读写。但RAID设计并不是用来处理IO请求，而是用于检测并且恢复磁盘故障。RAID本身比较复杂，这里我们假设故障都是很简单能够检测到，不会出现隐藏故障和不可访问的块。

评价RAID有三个方面：

* 容量，一块大小为N的硬盘实际可用空间是多少？
* 可靠性，设计可以容忍多少磁盘故障？
* 性能，RAID对于不同的负载下性能如何，差别大吗？

针对这些评估我们来分析几种常见的RAID设计思路。也有一些可量化的评估方法

* 单请求延迟：能够一定程度解释磁盘在单个IO操作中的并发性能
* 静态吞吐量：理论能够承载的最大并发带宽
* 顺序读写性能和随机读写性能：两种常见的工作负载代表在实际情况下能够表现的性能

RAID方法的命名很有意思，以级别为分隔，常见的有RAID-0、RAID-1、RAID-4、RAID-5等。

**第一种**是RAID-0，我们也称之为分条的方法，数据块在磁盘上的分布如下图所示，可以看到数据是没有冗余，即没有备份的。

<img src="http://1.14.100.228:8002/images/2022/03/13/20220314082902.png" style="zoom:80%;" />

可以看到这里有一种块大小的概念，直接影响的就是磁头在各个磁盘间定位的开销大小，块越大，磁盘定位时间越短，大部分系统的块比较大，用64KB左右大小的块。

对于RAID-0的结构分析可以知道，这种方法架构的磁盘阵列容量和性能都是十分不错的，单请求延迟也比较小，但是可靠性是最差的，因为没有任何的数据备份。

**第二种**是RAID-1，我们称之为镜像的方法，简单来讲就是选n个盘在相同位置放数据副本，具体结构如下图所示，一般镜像和分条是一起的，称之为RAID-10或者RAID-01，下图是RAID-10的方法。

<img src="http://1.14.100.228:8002/images/2022/03/13/20220314085343.png" style="zoom:80%;" />

镜像的保留了RAID-0的定位特点，多备份让镜像的方法有并发读、并发写的特点，即读可以随便读一个块，但是写要并行写进去，无论是顺序读写还是随机读写都是这样。对于RAID-1的结构分析可以知道，这种方法容量少一半，读写操作比RAID-0都要慢不少，但是可靠性很强，可以保证单个磁盘故障的检测和修复。

**注**：磁盘数据有备份时RAID会有持续数据更新的问题，如果磁盘在同时写入块时，一个块已经写好，此时发生断电，另一个块还没写好，这样就不同步了。解决方法就是在RAID里面放一些持久化的RAM，专门用来记录日志，就算断电，读取日志也可以知道下一步要干嘛。

**第三种**是RAID-4，也叫带有奇偶校验位的空间。最根本的改变是用一个磁盘来存放奇偶校验位，表示该条的冗余信息的正确性。如果学习过奇偶校验位的应用，这里应该很好理解。具体的，校验方法可以使用简单的XOR方法，如果这一片有偶数个1，奇偶校验位返回0，有奇数个1，奇偶校验位返回1，当有多个位时，数据在每一位上都放置奇偶校验位。具体结构如下图所示

<img src="http://1.14.100.228:8002/images/2022/03/13/20220314090149.png" style="zoom:80%;" />

这种方式使用很少的冗余数据实现了磁盘故障的检测，不过这种方法只允许一个磁盘故障，无法定位多个故障磁盘。注意，数据备份的目的就是实现磁盘故障的检测和恢复，这里本质上将每一个位的冗余数据压缩到一个位上，是一种极好的压缩方法，只不过丢失的信息有些多。

**第四种**是RAID-5，这基本上是RAID-4的原理，但是将奇偶校验位分布到不同磁盘上。因为如果将奇偶校验位都放在一个磁盘里，那么对同一的磁盘的随机写是无法同步进行的，因此如果有大量的随机写操作，RAID-4方法会出现无法容忍的延迟。

<img src="http://1.14.100.228:8002/images/2022/03/13/20220314091322.png" style="zoom:80%;" />

因此将奇偶校验位这样分开就可以做到对同一磁盘的并发随机写，有了这种提升以后，几乎现在所有的RAID-4都被RAID-5代替，还有一些基于软件的RAID可能会用RAID-4，因为系统本身知道不会进行大量随机写的操作。

我们可以对这些RAID实现方法的性能进行量化分析，如下表所示。

<img src="http://1.14.100.228:8002/images/2022/03/13/20220314091712.png" style="zoom:80%;" />

可以发现不同方法的特点都很明显，它们直接的利弊都很明显，所以可以根据设计目标简单的选出来合适的RAID方法，同时RAID还有其它等级，都有针对不同方面的内容，如针对延迟的RAID-2，和RAID-3、RAID-6等。

## 文件和目录

我们真正开始讨论文件的抽象，这也是重点部分，文件和目录的抽象是文件系统的基石，正如CPU、内存一样，文件也是系统内可共享的持久化存储资源，我们重点谈论一下UNIX文件系统中可交互的接口。

**文件与目录概述**

首先是基础概念，每一个文件都是一组二进制值，都有一个低位名称，用户通常不会注意到这个名称，这个低位名称通常会链接到inode数，即每个文件都有一个与之关联的inode号，文件系统设计之初就是就是存放并确保能够读取到数据。

然后是目录，目录抽象的内容有两种，一是文件-低级名称，一种是目录-目录。通过构建目录树，能够做到对所有文件的索引。一个磁盘就是一个目录系统，根目录就是最上层的目录，一般是\。这些概念和我们在windows中使用的文件管理器不同，文件系统是一种更加抽象宏观的设计，例如在UNIX里面，文件、设备、管道甚至进程都是由文件系统命名的。统一的命名系统让系统更简单、更模块化。再比如，统一的文件系统（一个磁盘分区）命名磁盘、u盘、CD-ROM和很多其它东西，这一切都位于一个单一的目录树下。

**文件接口**

接下来我们通过文件系统的接口处理流程来了解其工作原理

<img src="http://1.14.100.228:8002/images/2022/03/16/20220316125304.png" style="zoom:80%;" />

首先是创建文件，通过系统调用open来打开文件，函数open的描述如上图所示，可以看到open()有三个参数，第一个指定显式文件名，第二个创建文件，如果文件不存在则确保文件只能被写入，如果文件已经存在则将其截断为零个字节，第三个参数指定权限。open()返回的是一个文件描述符，文件描述符简单来讲可以看作是物理文件地址的指针，是其他文件系统调用的基础。

具体的讲，一个简单的数组跟踪每一个进程中已打开的文件，数组中每一个条目都指向一个file结构体，用于保存文件信息。这个表就是**开放文件表**，文件标识符用来打开这个表，表里保存的文件信息文件、当前偏移量、和其他相关细节，比如文件是可读还是可写。如下图所示

注：在xv6系统里面，所有这样的结构体保存在一个数组里面，并且这个数组自带一个锁。

<img src="http://1.14.100.228:8002/images/2022/03/16/20220316130146.png" style="zoom:80%;" />

注：strace是专门用来查看程序使用系统调用的工具，是一个十分强大的工具。

然后是读写文件，我们知道echo和cat命令可以用来构建简单的文件读写程序。我们查看这个简单简单命令的调用链。

<img src="http://1.14.100.228:8002/images/2022/03/15/20220316093736.png" style="zoom:80%;" />

cat做的第一件事是打开文件，O_RDONLY标志指示文件只打开读(不是写)，O_LARGEFILE表示使用64位偏移量。文件在打开后返回的标识符是3，那是因为0、1、2是进程在创建时就已经打开的文件了，它们分别是标准输入、标准输出和标准错误。

之后使用read()系统调用从文件中读取一些字节，read()的第一个参数是文件描述符，从而告诉文件系统要读取哪个文件，第二个参数指向一个缓冲区，其中将放置read()的结果，第三个参数是缓冲区的大小，在本例中为4 KB。对read()的调用成功时返回它读取的字符数，这里是”hello\n“六个字符。

接下来是write调用，将字符串写入文件1，也就是标准输出流，于是字符串在用户终端显示，同样返回输出的字符串长度，最后再次调用read试图得到更多数据，但是返回0，因此结束访问，删除文件引用。之后大部分的命令都是这样一个个系统调用组成的。

明显上面提到的读写read和write都是顺序读写，我们需要一种随机读写文件位的方法，这就是lseek调用，如下图所示。

<img src="http://1.14.100.228:8002/images/2022/03/16/20220316125827.png" style="zoom:80%;" />

其中fildes就是文件描述符，offset就是字符偏移量，whence表示三种offset发挥作用的方式。对于进程打开的每一个文件，操作系统会跟踪一个偏移量，这个偏移量决定了下一次读写文件会从哪一个地方开始，这个偏移量有两种方式进行更新。一是将N个字节的读写直接加到偏移量上(自动)，二是使用lseek调用来指定偏移量。系统调用与偏移量之间的关系如下图所示。

![](http://1.14.100.228:8002/images/2022/03/16/20220316130642.png)

很多时候，不只是多个进程会同时访问文件系统，多个线程也需要并发访问文件，但是如果这些线程都使用同一个文件描述符的话，它们就只能在相同的偏移量上进行读写。因此，系统提供了一个dup调用用来复制文件描述符，具体过程如下图所示。通过操作不同文件描述符，可以读取不同的偏移量，可以实现不同线程读写文件不同的区域。

write调用的其中一个特性是，先返回写入成功，再后台延迟写入。而有时我们需要让写入硬盘立即执行。因此我们可以使用fsync调用，fsync调用强制所有脏数据立刻写入磁盘。这会造成操作系统对脏数据的管理出现问题，但是增强了写入数据的安全性。

<img src="http://1.14.100.228:8002/images/2022/03/16/20220316163618.png" style="zoom:80%;" />

有时我们想要对文件进行重命名，我们可以用mv命令，而mv命令实际调用了rename，rename有操作上的**原子性**，这是为了防止系统崩溃造成的命名错误，从旧名到新名一步完成，不会有中间状态。具体的过程如下图所示

<img src="http://1.14.100.228:8002/images/2022/03/16/20220316170025.png" style="zoom:80%;" />

文件如此复杂，我们希望在文件系统中保存文件有关的所有数据，这种数据称为文件元数据。如果想要调用查看文件元数据，可以使用stat或者fstat调用来查看。具体的信息如下图所示。

<img src="http://1.14.100.228:8002/images/2022/03/16/20220316205352.png" style="zoom:80%;" />

这些元数据都存储在inode指向的地方，还有一份inode拷贝留在内存里面加速文件访问。

如果我们要删除文件，可以使用rm命令，照例我们查看rm命令的调用，发现它只是简单的调用了一个**unlink**函数。它的作用原理我们需要结合目录系统来一起讲。

**目录接口**

和文件一样，有一组与目录相关的系统调用能够创建、读取和删除目录。但是和文件不同的是，永远不能直接写入目录。因为目录的格式被认为是文件系统元数据，文件系统认为应该负责目录数据的完整性，只能通过创建文件、目录或其他对象类型等方式间接地更新目录。也就是说，目录是一种封装性强的结构。

特别的，一个空目录会有两个条目，一个引用自身，一个引用其父目录，使用`ls -a`可以在空目录中查看到`./ ../`两个文件，它们同时也是可以访问的。

ls命令也是读取目录的主要方式，照例我们查看ls的调用链，发现三个调用:opendir()、readdir()和closedir()，读取的信息来自于目录为其包含文件构造的结构体，称为目录表，目录表包含的信息比较简单，只有文件名和文件索引一点点，因此所以程序可能会对每个文件调用stat()，以获取每个文件的更多信息，这也就是`ls -l`的底层原理。

<img src="http://1.14.100.228:8002/images/2022/03/16/20220317095355.png" style="zoom:80%;" />

删除目录也是我们常用的一项操作，一种简单的调用是`rmdir()`，但是由于安全考虑，rmdir只能删除空目录。如果想要删除带有文件的目录，也就是删除所有文件，就需要了解删除文件和目录的关系。我们之前讲过删除文件实际调用的是`unlink()`函数，而与之相对的是`link()`，一种在文件系统树中创建条目的方法，该调用有两个参数，一个旧路径名和一个新路径名。另一种说法是，系统调用link，也就是命令`ln`，用来创建文件的引用关系。

**链接**

其底层原理就是将多个文件名链接到同一个文件名上，如下图所示，file和file2的inode是相同的，结合起来看，创建文件时，创建一个inode结构，同时将文件名硬链接到文件，因此rm的unlink都是删除文件名，而不是删除文件。

与这个机制对应的是文件系统会统计某个文件的引用个数，即reference count，当调用link时，引用数加一，调用unlink时，引用数减一，只有当引用计数达到0时，系统才会彻底删除文件。如下图所示。

<img src="http://1.14.100.228:8002/images/2022/03/16/20220317100610.png" style="zoom:80%;" />

 上面的链接方式有一个专门的名称，硬链接。相对的还有一种方式，即软链接，也叫符号链接，提出这一概念的原因是硬链接是有限制的，硬链接不能在同一个目录里面，因为有可能创建循环链接，也不能跨盘，因为inode号只在特定的文件系统中是唯一的。

创建软连接的方式也是使用ln命令，不过要加上-s标识符，即`ln -s`。如下图所示，软链接和硬链接不同，不是链接到同一个inode号，它实际上是一个路径，相当于原文件的另一个引用，删除文件演示也说明了这一原理。

<img src="http://1.14.100.228:8002/images/2022/03/16/20220317102508.png" style="zoom:80%;" />

**其它**

我们知道文件这一抽象资源是各种进程共有的，因此需要更严格的权限管理，在UNIX文件系统这种权限管理是通过权限位来实现的，如下图所示。

<img src="http://1.14.100.228:8002/images/2022/03/16/20220317103408.png" style="zoom:80%;" />

在上面的示例中，ls输出的前三个字符表明该文件的所有者(rw-)可以读和写，只有群组的成员和系统中的其他任何人(r——后跟r——)可以读。文件的所有者可以很简单的通过`chmod`命令更改文件访问模式，设置方法很简单，以`chmod 755`为例，7代表前三位设为111，即可读可写可执行，5表示中间三位设为101，表示可读可执行，另一个5同理。

**注：**在更复杂的文件系统里，还有一种更复杂的**访问控制列表**允许更精确地控制谁可以访问和操作信息。分布式文件系统AFS用ACL访问控制列表来管理用户权限

我们已经介绍了文件、目录和特殊类型的链接的接口，我们可以看出，文件系统的构建无非就是使用接口将文件和目录一个个挂载到系统中，如果想创建一个文件系统，可以使用`mkfs`调用，简单输入设备和文件系统类型。就能够创建一个空文件系统。创建出的文件系统不可能是孤立的，必须要挂载到已有的文件系统上，这要使用`mount`命令，如下图所示。

<img src="http://1.14.100.228:8002/images/2022/03/17/20220317111042.png" style="zoom:80%;" />

概念比较多，我们来做一些总结：

* 文件是一个字节数组，它可以被创建、读取、写入和删除。它有一个唯一引用它的低级名称(即数字)。低级别的名字通常被称为i-number。
* 目录是元组的集合，每个元组包含一个人类可读的名称和它映射到的底层名称。每个条目都指向另一个目录或一个文件。每个目录本身也有一个低级名称(i-number)。
* 访问文件后，操作系统会返回一个文件描述符，根据权限和意图的允许，这个文件描述符可以用于读写访问。
* 每个文件描述符是一个私有的、每个进程的实体，它引用了打开文件表中的一个条目。其中的条目跟踪该访问指的是哪个文件，文件的当前偏移量(即，下一次读写将访问文件的哪一部分)，以及其他相关信息。
* 调用read()和write()自然地更新当前偏移量;否则，进程可以使用lseek()来更改它的值，从而允许对文件的不同部分进行随机访问。
* 要在文件系统中使用多个人类可读的名称来引用同一个底层文件，要使用硬链接或软链接。每种方法在不同的情况下都是有用的，所以在使用之前要考虑它们的优缺点。请记住，删除文件只是在目录层次结构中执行最后一次unlink()操作。
* 大多数文件系统都有启用和禁用共享的机制。这种控制的基本形式是由权限位提供的；更复杂的**访问控制列表**允许更精确地控制谁可以访问和操作信息。

## 实现文件系统







































