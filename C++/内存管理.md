**delete和delete[]**

在C++中，new产生的对象需要通过delete来删除释放内存，我们有时能看到delete[]这种写法。它们之间的区别就是

我们在回收用 new 分配的单个对象的内存空间的时候用 delete，回收用new[]分配的一组对象的内存空间的时候用 delete[]

因为我们在new和delete时分为两种情况：

(1) 为基本数据类型分配和回收空间；(2) 为自定义类型（对象）分配和回收空间；

直观来看，假如P是new[]产生的对象，如`T array = new int [10]`，那么`delete P`时我们会发现只有 p[0] 这个对象调用了析构函数，其它对象如 p[1]、p[2] 等都没有调用自身的析构函数。

在析构函数中的内存释放操作将不会被执行（引发内存泄漏），已使用内存不断增加，这就是问题的症结所在。

如果用delete[]，则在回收空间之前所有对象都会首先调用自己的析构函数，已使用内存不会不断增加。

我们可以总结为，基本类型的对象没有析构函数，所以回收基本类型组成的数组空间用 delete 和 delete[] 都是应该可以的；但是对于类对象数组，只能用delete[]。对于 new 的单个对象，只能用 delete 不能用 delete[] 回收空间。 

> 其实自从c++14之后，不推荐使用new、delete来自己管理内存了，使用智能指针不失为更好的方式。









