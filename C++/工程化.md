## C++工程结构

首先参考这个链接：[干货：构建C/C++良好的工程结构 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/59450618)

- 构建系统：如CMakeLists.txt或者makefile脚本
- 自述文件：里面有说明和协议(License)，一般是README
- 源代码：如果这个工程是开源的，那么它会有它的源代码。很多开源工程源代码放在了src文件夹
- 头文件：基本上所有的开源库都会提供头文件。C/C++毕竟不像C#那样方便，你要知道类和函数的声明才可以正确使用它。



## 头文件和源文件

在用C++编写比较大型的项目时，代码文件非常多，因此文件的分割管理是十分有必要的，此时一个基本功能的实现依靠头文件和源文件配合，其中

**头文件(.h)**

写类的声明（包括类里面的成员和方法的声明）、函数原型、#define常数等，但一般来说不写出具体的实现。

在写头文件时需要注意，在开头和结尾处必须按照如下样式加上预编译语句（如下）：

~~~c++
#ifndef XXX_H
#define XXX_H

//类的声明、函数原型、#define常数等
Class XXX{
    private:
    public:
};

#endif
~~~

这样做是为了防止重复编译，不这样做就有可能出错。至于CIRCLE_H这个名字实际上是无所谓的，只要符合规范都行。

但原则上来说，非常建议把它写成这种形式，因为比较容易和头文件的名字对应。

**源文件（.cc）**

源文件主要写实现头文件中已经声明的那些函数的具体代码。需要注意的是，开头必须#include一下实现的头文件，以及要用到的头文件。

例如我们要实现上面的类中的成员，需要写一个源文件（XXX.cc）

~~~c++
#include "XXX.h"

XXX::method1(){};
XXX::method2(){};
~~~

这样就组成了一个基本功能的编写。

***

现在还用C++实现的大多是轮子，因为轮子需要的稳定和高效只有用大量的C++代码（或者Rust）才能堆出来。在使用C++造轮子的工程当中，会利用到多种C++的特性和C++独特（麻烦）的设计模式，就我目前看到的而言，主要会涉及到有分级类、指针＆引用和容器应用，涉及到的方面分别是：

* 轮子基础固件的分层架构
* 数据安全和操作安全

* 数据结构的高效实现

我们就以这几点来了解`C++如何造轮子`

## 分级类

在造轮子之前我们要想这个轮子的基本功能有哪些，我们对它的**期望**是什么，也就是对其进行抽象，这一步我们不管如何实现的问题，只是想组成轮子的固件有哪些，它们分别是什么，我们对它们有什么功能上的期望，谁操作哪些数据，谁的结果是谁的输入，一个个的分析总结，最终我们应该会整理出一些“理想化”的轮子组件，它们之间有逻辑关系，但是对于自身来说是完整的，这就是我们要做到的第一步。

因为我们不可能像python一样的在一个大类里面把功能全部写完，因此我们需要这种分层架构帮助我们构建这个轮子的总体架构，如何实现这些“理想化”的组件，因为每一个轮子的功能和所需组件都不同，因此这部分根据项目各异，但是总结来说的话，这一问题换一种说法就是如何高效实现分级类。这是一个非常广泛的问题，我能力有限也理不清，但是可以从一个实际例子来初步窥探其思想：

假设我们已经实现了DiskManager，它的功能可总结为：接入数据库，打开/创建 数据库文件/日志文件，函数为：

* ShutDown、WritePage、ReadPage、WriteLog、ReadLog

可以看出DiskManager完成了对数据库来说，磁盘管理所需的功能抽象。接下来开始正式架构一个轮子。

****

我们要实现的轮子是单个缓冲池`BufferPoolManagerInstance`，即一个原始缓冲池的实例。 我们知道，对缓冲池来说，应当具有以下功能期望：

* 缓冲池能够将磁盘中的`页`整块读取到内存中，并组织这些`页`，形成一种结构
* 缓冲池能够提供某种方便的方式读取其中的`页`
* 缓冲池能够支持`置换器`将缓存的页数据重新写回磁盘中
* 缓冲池能够通过一定的机制保持并发安全，相同时间内多个请求不会读取到不同的数据

此时我们将缓冲池抽象为了一种数据结构，与它交互的只有磁盘和其他应用（统称为其它应用），它从磁盘获取数据，并提供其它应用读取这些数据的方法，并保证一定的安全性，就这么简单。

****

第一步的抽象完成了，接下来我们发现，完成缓冲池的功能，我们还需要另外一些抽象：

* `Page`：对页本身的抽象，这是缓存池操作的数据
* `PageTable`：管理缓冲池已经分配的空间，提供页索引，这是缓冲池能够方便读取数据的保证
* `Replacer`：置换器将缓存的页数据重新写回磁盘中
* `FreeList`：管理缓冲池的剩余空间
* `Lock`：提供并发访问支持

这些抽象是缓冲池的基础，它们单拿出来本身也是独立的，有各自的方法和属性。通过一定的逻辑将这些抽象通过一定逻辑组合起来就变成了另一个完整的抽象—缓冲池。

****

一个大系统的抽象过程也类似缓冲池的抽象过程，但是要复杂的多。上面所讲的缓冲池只是最简单的缓冲池，实际DBMS所使用的缓冲池会更多复杂的功能和调度，所需的抽象也会更多，更复杂。

所谓的架构就是将简单的东西用逻辑加以组合并不断累积，最终呈现出来的就是我们所看到的某种功能特性，功能经过逻辑组织就变成了系统。

为什么叫分层类呢？目前占据抽象实现的绝大部分思想都是面向对象思想。因此我们说将分层抽象实现，就是在说分层类的实现，某种意义上这两者可以说是相同的东西了。

## 编译和链接

详细：[(37条消息) g++编译详解_三级狗的博客-CSDN博客_g++ 编译](https://blog.csdn.net/Three_dog/article/details/103688043)

### 基础

一份可执行的C++程序由主程序和相应的类头文件、类实现组成，一个完整的C++编译过程（例如g++ a.cpp生成可执行文件），总共包含以下四个过程：

- 编译预处理，也称预编译，可以使用命令`g++ -E`执行
- 编译，可以使用`g++ -S`执行
- 汇编，可以使用`as` 或者`g++ -c`执行
- 链接，可以使用`g++ xxx.o xxx.so xxx.a`执行

假设有简单的程序文件`test.cpp`、 `test.h`、 `main.cpp`，文件内容如下：

~~~c++
_____________main.cpp_______________
#include "test.h"

int main (int argc, char **argv)
{
    Test t;
    t.hello();
    return 0;
}
_____________test.h_______________
#ifndef _TEST_H_ 
#define _TEST_H_ 

class Test
{
public:
    Test();
    void hello();
    ~Test();
};
#endif  //TEST
_____________test.cpp_______________
#include "test.h"
#include <iostream>
using namespace std;
Test::Test() {}

void Test::hello()
{
    cout << "hello" << endl;
}

Test::~Test() {}
~~~

编译链接的过程看上去复杂，但是从结果来看，无非就是从源代码生成中间文件再链接成最终的目标可执行文件的过程，所以无论用什么flag，怎样编译链接，只要能达到目的就都可以，例如下面几种方式都可以生成最终我们所需的执行文件`test`：

**直接生成**

> g++ test.h test.cpp main.cpp -o test

**分别编译链接**

> g++ test.cpp -c -o test.o
> g++ main.cpp -c -o main.o
> g++ main.o test.o -o test.out

**编译预处理-编译-汇编-链接**

> // 替换宏
> g++ -E test.cpp test.h -o test.ii
> g++ -E main.cpp test.h -o main.ii
>
> // 根据机器生成汇编码
> g++ -S test.ii -o test.s
> g++ -S main.ii -o main.s
>
> // 生成二进制机器码
> g++ -c test.s -o test.o
> g++ -c main.s -o main.o
> 
> // 链接生成可执行文件
> g++ main.o test.o -o test.out

这里推荐第二种编译链接方式，第三种太复杂了

### 编译动态库和静态库

**生成静态库**

使用`ar`命令进行“归档”（.a的实质是将文件进行打包），生成静态库，链接的时候将整个文件链接进输出文件中。

```bash
ar crsv libtest.a test.o 
```

- `r` 替换归档文件中已有的文件或加入新文件 (必要)
- `c` 不在必须创建库的时候给出警告
- `s` 创建归档索引
- `v` 输出详细信息

**生成动态库**

使用`g++ -shared`命令指定编译生成的是一个动态库

~~~bash
g++ test.cpp -fPIC -shared -Wl,-soname,libtest.so -o libtest.so.0.1
~~~

- `shared`:告诉编译器生成一个动态链接库
- `-Wl,-soname`:指示生成的动态链接库的别名（这里是libtest.so）
- `-o`:指示实际生成的动态链接库（这里是libtest.so.0.1）
- `-fPIC`
  - fPIC的全称是 `Position Independent Code`， 用于生成位置无关代码（看不懂没关系，总之加上这个参数，别的代码在引用这个库的时候才更方便，反之，稍不注意就会有各种乱七八糟的报错）。
  - 使用-fPIC选项生成的动态库，是位置无关的。这样的代码本身就能被放到线性地址空间的任意位置，无需修改就能正确执行。通常的方法是获取指令指针的值，加上一个偏移得到全局变量/函数的地址。
  - 关于PIC参数的详细解读：[点此链接](http://blog.sina.com.cn/s/blog_54f82cc201011op1.html)

库中函数和变量的地址是**相对地址**，不是**绝对地址**，真实地址在调用动态库的程序加载时形成。

> **注意:**
>
> - 生成的库文件总是以libXXX开头，这是一个约定，因为在编译器通过-l参数寻找库时，比如-lpthread会自动去寻找libpthread.so和libpthread.a。
> - 如果生成的库并没有以lib开头，编译的时候仍然可以连接到，不过只能以显示加在编译命令参数里的方式链接。例如g++ main.o test.so

### 静态编译和动态编译

编译C++的程序可以分为动态编译和静态编译两种

**静态编译**

链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。这种称为静态编译，静态编译中使用的库就是静态库（`*.a` 或`*.lib`）生成的可执行文件在运行时不需要依赖于链接库。

~~~bash
g++ main.o libtest.a -o a.out
~~~

**动态编译**

动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。

动态编译中使用的库就是动态库（*.so 或*.dll）

动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。

动态库在链接过程中涉及到加载时符号重定位的问题，感兴趣的同学参看链接：动态编译原理分析

~~~bash
g++ main.o libtest.so -编译参数
~~~

### 链接参数

如果用`g++ main.o libtest.so -o name`直接生成文件的话是无法运行的，原因是找不到动态链接库`libtest.so`。

那么明明编译成功，运行时为什么会找不到库？为了弄清这个问题，我们需要对链接动态库的过程有一个更深入的理解。

我们在main.cpp中明确引用到了Test类，所以在编译进行到最后阶段，链接的时候。如果在所有参与编译的文件中没能检索到Test这个符号，则会报错未定义的引用。
所以在编译过程中必须能够找到包含Test符号的文件，可以是.o、.a、或者.so。

如果是.o或者.a，也就是静态链接，那么它会将.o或者.a中的内容一起打包到生成的可执行文件中，生成的可执行文件可以独立运行不受任何限制。

而如果是.so这种动态链接库，就比较麻烦了。链接器将不会把这个库打包到生成的可执行文件里，而仅仅只会在这里记录一个地址，告诉程序，如果遇到Test符号，你就去文件libtest.so的第三行第五列（打个比方，实际是一个相对的内存地址）找它的定义。

综上所述：

- 编译链接main.cpp的时候，必须能够找到libtest.so的动态库，记录下Test符号的偏移地址。
- 运行的时候，程序必须找到libtest.so，然后寻址找到Test

**-L和-l**

`-L` 与 `-l` 链接器参数，就是指定链接时去（哪里）找（什么）库。

- -l，代表链接哪个库，会自动检索lib开头的对应库名。 例如-lpthread,-lQt5Core。会自动检索libpthread.so,libpthread.a,libQt5Core.so,libQt5Core.a
  - 如果静态库动态库同时存在，优先链接动态库
- -L，指定去哪里找库文件。例如指定：-L/home/threedog/test，则在编译时会优先检索/home/threedog/test/libpthread.so等文件。
- 链接库最直接的办法是不用任何参数，直接写库的路径加载编译参数里。
- 查找顺序
  - 如果直接写的库的全路径，则会直接去找到库，不走下面的顺序检索。
  - -L，优先级最高
  - 然后是系统的环境变量LIBRARY_PATH
  - 最后再找内定目录 /lib /usr/lib /usr/local/lib 这是当初编译 gcc时写在程序内的
  - 如果都找不到，会报错找不到文件或找不到-lxxxx

所以以上的编译命令，可以通过多种方式通过编译：

- `g++ main.o libtest.so`，或`g++ main.o ./libtest.so`
- g++ main.o /home/threedog/test/libtest.so
- g++ main.o -ltest -L.，或g++ main.o -ltest -L/home/threedog/test/
- LIBRARY_PATH=. g++ main.o -ltest，或LIBRARY_PATH=/home/threedog/test/ g++ main.o -ltest
- 或者把libtest.so拷贝到/usr/lib目录下去。

**-Wl,-rpath**

通过上面的方法编译出的a.out，运行会报错，通过ldd命令查看，发现编译时链接的`libtest.so`成了`not found`，这就引出了第二个问题：如何让程序运行的时候能够找到对应的库。

`-Wl,-rpath`就是做这个事情的：`-Wl`代表后面的这个参数是一个链接器参数，`-rpath`+库所在的目录，会给程序明确指定去哪里找对应的库。

~~~bash
g++ main.o libtest.so -Wl,-rpath='pwd'
~~~

![](http://pic.netpunk.space/images/2022/09/18/20220918145845.png)

另外，也可以通过在环境变量`LD_LIBRARY_PATH`里添加路径的方式成功运行

![](http://pic.netpunk.space/images/2022/09/18/20220918145912.png)

运行时库的查找顺序：

1. 编译目标代码时指定的动态库搜索路径（-rpath）；
2. 环境变量LD_LIBRARY_PATH指定的动态库搜索路径；
3. 配置文件/etc/ld.so.conf中指定的动态库搜索路径；
4. 默认的动态库搜索路径/lib；
5. 默认的动态库搜索路径/usr/lib.

### 头文件搜索原则

上面提到了编译时链接库的查找顺序和运行时动态库的检索顺序，顺便再提一下C++编译时头文件的检索顺序：

- `#include<file.h>`只在默认的系统包含路径搜索头文件
- `#include"file.h"`首先在当前目录以及`-I`指定的目录搜索头文件, 若头文件不位于当前目录, 则到系统默认的包含路径搜索

顺序：

1. 先搜索当前目录
2. 然后搜索-I指定的目录
3. 再搜索gcc的环境变量CPLUS_INCLUDE_PATH（C程序使用的是C_INCLUDE_PATH）
4. 最后搜索gcc的内定目录
   - /usr/include
   - /usr/local/include
   - /usr/lib/gcc/x86_64-redhat-linux/4.1.1/include



