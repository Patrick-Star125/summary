## C++工程结构

首先参考这个链接：[干货：构建C/C++良好的工程结构 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/59450618)

- 构建系统：如CMakeLists.txt或者makefile脚本
- 自述文件：里面有说明和协议(License)，一般是README
- 源代码：如果这个工程是开源的，那么它会有它的源代码。很多开源工程源代码放在了src文件夹
- 头文件：基本上所有的开源库都会提供头文件。C/C++毕竟不像C#那样方便，你要知道类和函数的声明才可以正确使用它。



## 头文件和源文件

在用C++编写比较大型的项目时，代码文件非常多，因此文件的分割管理是十分有必要的，此时一个基本功能的实现依靠头文件和源文件配合，其中

**头文件(.h)**

写类的声明（包括类里面的成员和方法的声明）、函数原型、#define常数等，但一般来说不写出具体的实现。

在写头文件时需要注意，在开头和结尾处必须按照如下样式加上预编译语句（如下）：

~~~c++
#ifndef XXX_H
#define XXX_H

//类的声明、函数原型、#define常数等
Class XXX{
    private:
    public:
};

#endif
~~~

这样做是为了防止重复编译，不这样做就有可能出错。至于CIRCLE_H这个名字实际上是无所谓的，只要符合规范都行。

但原则上来说，非常建议把它写成这种形式，因为比较容易和头文件的名字对应。

**源文件（.cc）**

源文件主要写实现头文件中已经声明的那些函数的具体代码。需要注意的是，开头必须#include一下实现的头文件，以及要用到的头文件。

例如我们要实现上面的类中的成员，需要写一个源文件（XXX.cc）

~~~c++
#include "XXX.h"

XXX::method1(){};
XXX::method2(){};
~~~

这样就组成了一个基本功能的编写。

***

现在还用C++实现的大多是轮子，因为轮子需要的稳定和高效只有用大量的C++代码（或者Rust）才能堆出来。在使用C++造轮子的工程当中，会利用到多种C++的特性和C++独特（麻烦）的设计模式，就我目前看到的而言，主要会涉及到有分级类、指针＆引用和容器应用，涉及到的方面分别是：

* 轮子基础固件的分层架构
* 数据安全和操作安全

* 数据结构的高效实现

我们就以这几点来了解`C++如何造轮子`

## 分级类

在造轮子之前我们要想这个轮子的基本功能有哪些，我们对它的**期望**是什么，也就是对其进行抽象，这一步我们不管如何实现的问题，只是想组成轮子的固件有哪些，它们分别是什么，我们对它们有什么功能上的期望，谁操作哪些数据，谁的结果是谁的输入，一个个的分析总结，最终我们应该会整理出一些“理想化”的轮子组件，它们之间有逻辑关系，但是对于自身来说是完整的，这就是我们要做到的第一步。

因为我们不可能像python一样的在一个大类里面把功能全部写完，因此我们需要这种分层架构帮助我们构建这个轮子的总体架构，如何实现这些“理想化”的组件，因为每一个轮子的功能和所需组件都不同，因此这部分根据项目各异，但是总结来说的话，这一问题换一种说法就是如何高效实现分级类。这是一个非常广泛的问题，我能力有限也理不清，但是可以从一个实际例子来初步窥探其思想：

假设我们已经实现了DiskManager，它的功能可总结为：接入数据库，打开/创建 数据库文件/日志文件，函数为：

* ShutDown、WritePage、ReadPage、WriteLog、ReadLog

可以看出DiskManager完成了对数据库来说，磁盘管理所需的功能抽象。接下来开始正式架构一个轮子。

****

我们要实现的轮子是单个缓冲池`BufferPoolManagerInstance`，即一个原始缓冲池的实例。 我们知道，对缓冲池来说，应当具有以下功能期望：

* 缓冲池能够将磁盘中的`页`整块读取到内存中，并组织这些`页`，形成一种结构
* 缓冲池能够提供某种方便的方式读取其中的`页`
* 缓冲池能够支持`置换器`将缓存的页数据重新写回磁盘中
* 缓冲池能够通过一定的机制保持并发安全，相同时间内多个请求不会读取到不同的数据

此时我们将缓冲池抽象为了一种数据结构，与它交互的只有磁盘和其他应用（统称为其它应用），它从磁盘获取数据，并提供其它应用读取这些数据的方法，并保证一定的安全性，就这么简单。

****

第一步的抽象完成了，接下来我们发现，完成缓冲池的功能，我们还需要另外一些抽象：

* `Page`：对页本身的抽象，这是缓存池操作的数据
* `PageTable`：管理缓冲池已经分配的空间，提供页索引，这是缓冲池能够方便读取数据的保证
* `Replacer`：置换器将缓存的页数据重新写回磁盘中
* `FreeList`：管理缓冲池的剩余空间
* `Lock`：提供并发访问支持

这些抽象是缓冲池的基础，它们单拿出来本身也是独立的，有各自的方法和属性。通过一定的逻辑将这些抽象通过一定逻辑组合起来就变成了另一个完整的抽象—缓冲池。

****

一个大系统的抽象过程也类似缓冲池的抽象过程，但是要复杂的多。上面所讲的缓冲池只是最简单的缓冲池，实际DBMS所使用的缓冲池会更多复杂的功能和调度，所需的抽象也会更多，更复杂。

所谓的架构就是将简单的东西用逻辑加以组合并不断累积，最终呈现出来的就是我们所看到的某种功能特性，功能经过逻辑组织就变成了系统。

为什么叫分层类呢？目前占据抽象实现的绝大部分思想都是面向对象思想。因此我们说将分层抽象实现，就是在说分层类的实现，某种意义上这两者可以说是相同的东西了。

## 指针＆引用



## 容器应用







































