## 图

 [数据结构：图（Graph） - 简书 (jianshu.com)](https://www.jianshu.com/p/bce71b2bdbc8) 

### 图的概念和性质

**基本概念**

理论上，图就是一堆顶点和边对象 ，就像这样，边可以有方向，也可以没有，有方向边的图称为有向图，反之为无向图

![](http://1.14.100.228:8002/images/2022/01/10/1.webp)

图作为一种多对多的数据储存结构，能够更强的表示现实事物的关系，从表示上讲，用尖括号表示有向边和有向图，用圆括号表示无向边和无向图

**无向完全图：**如果任意两个顶点都有一条边直接相连，那么就是无向完全图，有n(n-1)/2条边

**有向完全图：**如果任意两个顶点之间都有一条弧直接到达，那么就是有向完全图，有n(n-1)条边

**图的度：**图的度数之和是边数的两倍

**连通图：**在无向图G中，每一个结点之间都有路径存在，则是连通图

**生成树：**

### 图的储存

在代码中表述图有两种主要的方法：邻接列表和邻接矩阵

**邻接矩阵**

在邻接矩阵实现中，由行和列都表示顶点，由两个顶点所决定的矩阵对应元素表示这里两个顶点是否相连、如果相连这个值表示的是相连边的权重。例如，如果从顶点A到顶点B有一条权重为 5.6 的边，那么矩阵中第A行第B列的位置的元素值应该是5.6。

![](http://1.14.100.228:8002/images/2022/01/10/3.webp)

**邻接表**

在邻接列表实现中，每一个顶点会存储一个从它这里开始的边的列表。比如，如果顶点A 有一条边到B、C和D，那么A的列表中会有3条边，邻接列表只描述了指向外部的边。A 有一条边到B，但是B没有边到A，所以 A没有出现在B的邻接列表中。查找两个顶点之间的边或者权重会比较费时，因为遍历邻接列表直到找到为止。

![](http://1.14.100.228:8002/images/2022/01/10/2.webp)

这里写一种邻接矩阵和邻接表的简单实现

~~~c
#define N  6 //一般矩阵大小是动态定义的
//邻接矩阵数据结构
typedef  struct {
    int vcount;//顶点数
    int type ;//0 无向图，1 有向图
    char  vexs[N]  ;     // 顶点信息
    int  arcs[N][N]; //关系矩阵
} GraphMatrix;

//邻接表数据结构
struct EdgeNode { //边表中的结点
    int  endvex;     //相邻顶点在顶点表中下标
    int  weight;  //边的权
    struct EdgeNode  * nextedge;   //链字段
};
typedef struct EdgeNode * EdgeList;

typedef struct {
    char  vertex;  //记录顶点信息
    int degree;//用于记录顶点的入度，在拓扑排序时需使用
    EdgeList  edgelist;  //指向边表的指针
} VexNode;
typedef struct {
    VexNode  vexs[N];  //N个顶点
    int type ;//0无向图，1有向图
    int vcount;//顶点数
} GraphList;
~~~

从邻接表和邻接矩阵的性质可以看出，邻接表存储图相对于邻接矩阵大大节约了存储空间，但是寻找结点的度比较困难，相对的，邻接矩阵虽然空间利用率低，但是寻找结点的度很方便。

### 图的遍历

图是一种非欧几里得数据，对其遍历具有一些与其它数据结构不同的性质

* 图的遍历方法有深度和广度两种
* 连通图是遍历能够进行到底的前提

**深度优先遍历**

就像遍历树一样的递归遍历就可以了

这里提供一种深搜的邻接表实现

~~~c
https://blog.51cto.com/sndapk/2693065
~~~

**广度优先遍历**

就像遍历树一样的递归遍历就可以了

这里提供一种广搜的邻接表实现

~~~c
https://blog.51cto.com/sndapk/2693071
~~~

**遍历性能分析**

|  时间复杂度  | 邻接表 | 邻接矩阵 |
| :----------: | :----: | :------: |
| 深度优先遍历 | O(n+e) |          |
| 广度优先遍历 |        |  O(n^2)  |

|  空间复杂度  | 邻接表 | 邻接矩阵 |
| :----------: | :----: | :------: |
| 深度优先遍历 |        |          |
| 广度优先遍历 |        |          |

### 图的应用

图经常用于优化与搜索问题中，算法应用非常广泛，这里列举出一些图的基本应用算法

**最小生成树：**在无向连通加权图上定义一种权值之和最小的生成树

* 该定义是在无向连通图的基础上的
* 最小生成树可能不唯一，但是其权值之和是唯一的
* 对于n个结点的图，其生成树中必定有n-1条边

prim算法实现

prim算法：基于结点的贪心算法

1. 建立两个集合，一个取点，一个删点
2. 按路径最短的取点和删点，直到点删完

kruskal算法：基于边权的贪心算法

1. 把所有边取出来排序，一个个的遍历，只要不形成回路就取出来
2. 直到所有点都连上

kruskal算法实现

**拓扑排序：**对有向无环图的顶点的一种排序

1. 找图中入度为0的顶点，并且删除出边，输出该点
2. 重复1，直到没有输出（要么没点，要么有环，拓扑排序失败）

拓扑排序算法实现

**最短路径（dijkstra算法）**

做太多了

dijkstra算法实现

**关键路径**

在VOC图中，找关键路径就是找到权值相加最大的那条关键序列

关键路径算法实现

