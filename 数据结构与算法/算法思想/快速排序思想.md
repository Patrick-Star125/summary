## 基本思想

* 标准值是随机选的
* 循环不变量的应用
* 一轮递归后元素位置确认

快速排序有各个版本，能够解决不同的问题，适用于不同种类的数据。

我自己的理解：用**递归的手段**，切分排序数据规模**(分治)**，在小规模数据上随机选择一个pivot，按照**一定的排序方式**编排顺序，使其划为**三个部分**，[小于pivot，等于pivot，大于pivot]，关键在于让各个元素**尽快**到达它**应该在的位置**。


基本上，快排和分治的异同可以用分治的方式不同来概括

![](http://pic.netpunk.space/images/2022/10/25/20221025174016.png)

为了防止递归树过深，在选择pivot时要进行随机选择

**基础快排(随机选择切分元素)**

对于随机排布、重复值较少的数据，使用基础快排就可以达到比较好的效果。

~~~C++
int partition(SortObject *Rec, int low, int high) {
    DataType tmp = Rec->data[low];
    while (low != high) {
        while (low < high && Rec->data[high] >= tmp)high--; //在这里调整排序的顺序
        if (low < high) {
            Rec->data[low] = Rec->data[high];
            low++;
        }
        while (low < high && Rec->data[low] <= tmp)low++; //在这里调整排序的顺序
        if (low < high) {
            Rec->data[high] = Rec->data[low];
            high--;
        }
    }
    Rec->data[low] = tmp;
    return low;
}

void quickSort(SortObject *Rec, int low, int high) {
    int pivot;
    if (low >= high)return;
    pivot = partition(Rec, low, high);
    quickSort(Rec, low, pivot - 1);
    quickSort(Rec, pivot + 1, high);
}
~~~

**双路快排(随机选择切分元素)**

对于重复值较多的数据，为了减少冗余计算，对pivot进行单独分配处理。





**三路快排(随机选择切分元素)**

和双路快排类似，但是对重复值相当的极端情况更有效。





