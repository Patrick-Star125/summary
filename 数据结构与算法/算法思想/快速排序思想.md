## 基本思想

* 标准值是随机选的
* 循环不变量的应用
* 一轮递归后元素位置确认

快速排序有各个版本，能够解决不同的问题，适用于不同种类的数据。

我自己的理解：用**递归的手段**，切分排序数据规模**(分治)**，在小规模数据上随机选择一个pivot，按照**一定的排序方式**编排顺序，使其划为**三个部分**，[小于pivot，等于pivot，大于pivot]，关键在于让各个元素**尽快**到达它**应该在的位置**。


基本上，快排和分治的异同可以用分治的方式不同来概括

![](http://pic.netpunk.space/images/2022/10/25/20221025174016.png)

为了防止递归树过深，在选择pivot时要进行随机选择

**基础快排(随机选择切分元素)**

对于随机排布、重复值较少的数据，使用基础快排就可以达到比较好的效果。

~~~C++
class Solution {
public:
    int partition(vector<int>& nums, int left, int right){
        // assign r_pos to any random value in the range [left..right]
        int r_pos = rand() % (right - left + 1) + left;
        swap(nums[left], nums[r_pos]);
        // loop invariant 1: pivot
        int pivot = nums[left];
        int j = left;
        // loop invariant 2: nums[left+1, j] <= pivot
        // loop invariant 3: nums(j, right) > pivot
        for(int i=left+1;i<=right;i++){
            if (nums[i] <= pivot) {
                j++;
                swap(nums[i], nums[j]);
            }
        }
        swap(nums[left], nums[j]);
        return j;
    }

    void quickSort(vector<int>& nums, int left, int right){
        if (left<right){
            int pos = partition(nums, left, right);
            quickSort(nums, left, pos-1);
            quickSort(nums, pos+1, right);
        }
    }

    vector<int> sortArray(vector<int>& nums) {
        srand((unsigned)time(NULL)); //set random seed
        quickSort(nums, 0, nums.size()-1);
        return nums;
    }
};
~~~

**双路快排(随机选择切分元素)**

对于重复值较多的数据，为了减少冗余计算，也就是降低递归树的深度，对pivot进行单独分配处理，只需要更改partition的逻辑即可。

~~~c++
class Solution {
public:
    int partition(vector<int>& nums, int left, int right){
        // assign r_pos to any random value in the range [left..right]
        int r_pos = rand() % (right - left + 1) + left;
        swap(nums[left], nums[r_pos]);
        int pivot = nums[left];
        int le = left + 1; //less equals
        int ge = right; //greater equals
        while(true){
            while (le <= ge && nums[le] < pivot) {
                le++;
            }
            while (le <= ge && nums[ge] > pivot) {
                ge--;
            }
            if (le >= ge) {
                break;
            } else {
                swap(nums[le], nums[ge]);
                le++;
                ge--;
            }
        }
        swap(nums[left], nums[ge]);
        return ge;
    }

    void quickSort(vector<int>& nums, int left, int right){
        if (left<right){
            int pos = partition(nums, left, right);
            quickSort(nums, left, pos-1);
            quickSort(nums, pos+1, right);
        }
    }

    vector<int> sortArray(vector<int>& nums) {
        srand((unsigned)time(NULL)); //set random seed
        quickSort(nums, 0, nums.size()-1);
        return nums;
    }
};
~~~

**三路快排(随机选择切分元素)**

和双路快排类似，但是对重复值相当多的极端情况更有效（业务场景比较特殊）。

~~~c++
class Solution {
public:
    void quickSort(vector<int>& nums, int left, int right){
        if (left<right){
            // assign r_pos to any random value in the range [left..right]
            int r_pos = rand() % (right - left + 1) + left;
            swap(nums[left], nums[r_pos]);
            int pivot = nums[left];
            int lt = left + 1;//range num[left..lt) less than pivot
            int gt = right;//range num[gt..right] greater than pivot
            int eq   = left + 1;//range num[lt..eq] equal to pivot
            while(eq<=gt){
                if (nums[eq] < pivot){
                    swap(nums[lt], nums[eq]);
                    lt++;
                    eq++;
                } else if (nums[eq] == pivot){
                    eq++;
                } else {
                    swap(nums[eq], nums[gt]);
                    gt--;
                }
            }
            swap(nums[left], nums[lt-1]);
            quickSort(nums, left, lt-2);
            quickSort(nums, gt+1, right);
        }
    }

    vector<int> sortArray(vector<int>& nums) {
        srand((unsigned)time(NULL)); //set random seed
        quickSort(nums, 0, nums.size()-1);
        return nums;
    }
};
~~~





