# 查找

**总结**

|  排序算法  |  时间复杂度   | ASL（查找成功） | ASL（查找失败） |
| :--------: | :-----------: | :-------------: | :-------------: |
|  顺序查找  |     O(n)      |     (n+1)/2     |       n+1       |
|  二分查找  |    O(logn)    |   log  (n+1)    |    log(n+1)     |
|  分块查找  |               |                 |                 |
| 二叉排序树 | O(logN)或O(N) |                 |                 |
| 线性探测表 |               |    计算公式     |    计算公式     |

**内部查找：**只用在内存中进行查找

**外部查找：**需要通过IO进行查找

**ASL（平均查找-比较长度）：**一种衡量查找算法的优劣的指标

## 有序表查找

**二分查找**

对于有序表，大多用二分查找的方法

~~~c
int binary_search(int target, int list[], int length) {
    int mid, low, high;
    low = 0;
    high = length - 1;
    while (low <= high) {
        mid = (high + low) / 2;
        int num = list[mid];
        if (num == target) {
            return mid;
        } else if (num > target) {
            high = mid - 1; //如果目标在前半段
        } else if (num < target) {
            low = mid + 1;  //如果目标在后半段
        }
    }
    return -1;
}
~~~

关于二分查找，leetcode上有十分好的资料

| 题号 |                             链接                             |                             题解                             |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 704  | [704. 二分查找 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/binary-search/) |                                                              |
| 278  | [278. 第一个错误的版本 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/first-bad-version/) |                                                              |
|  35  | [35. 搜索插入位置 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/search-insert-position/) | [写对二分查找不是套模板并往里面填空，需要仔细分析题意 ](https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/) |

在题解中，大佬表示二分查找不能盲目套模板，二分查找只有一个思想，那就是：**逐步缩小搜索区间**

这一点决定了，二分查找可以不止应用在有序数组上，例如「力扣」上有一些问题输入数组不是有序的，例如「旋转有序数组」「山脉数组」（题号在第三部分的习题列表里），这些问题题目给出的是「接近有序」的数组，依然可以使用「二分查找」，这是因为这些数组都有规律可循，可以根据看到的 num[mid] 的值，推测两侧元素的性质，进而缩小搜索区间。

## 线性索引查找

**分块查找**

* 分块查找也称为索引顺序块的查找。是处理大量数据查找的一种方法。它把整个有序表分成若干块
* 块内的元素可以是有序的，也可以是无序的，块之间必须是有序的
* 每块不需要均匀，可能不满

~~~c
https://cdmana.com/2021/12/202112122203011192.html
~~~

**稠密查找**



**倒排查找**



## 单路查找树

### 二叉排序树

若其左子树非空，则左子树上所有结点的值均小于根结点的值;若其右子树非空，则其右子树上所有结点的值均大于根结点的值；并且其左、右子树均是如上定义的二叉查找树。

关于二叉排序树的基础实现，我们首先定义二叉树，和一些其它的辅助定义。

~~~c
#define TRUE 1
#define FALSE 0
#define DataType int
#define KeyType int
/* 二叉排序树的节点结构定义 */
typedef struct BiTNode
{
    int data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;
~~~

二叉排序树的创建过程如下

* 查找某一数据在二叉树中是否存在
* 若存在，返回值
* 若不存在，在树中插入值

二叉排序树的查找

~~~c
int SearchBST(BiTree T, DataType key, BiTree f, BiTree *p){
    //如果 T 指针为空，说明查找失败，令 p 指针指向查找过程中最后一个叶子结点，并返回查找失败的信息
    if (!T) {
        *p = f;
        return FALSE;
    }
    //如果相等，令 p 指针指向该关键字，并返回查找成功信息
    else if (key == T->data) {
        *p = T;
        return TRUE;
    }
    //如果 key 值比 T 根结点的值小，则查找其左子树；反之，查找其右子树
    else if (key < T->data) {
        return SearchBST(T->lchild, key, T, p);
    }
    else {
        return SearchBST(T->rchild, key, T, p);
    }
}
~~~

二叉排序树的插入

~~~c
int InsertBST(BiTree *T, DataType e) {
    BiTree p = NULL;
    //如果查找不成功，需做插入操作
    if (!SearchBST((*T), e, NULL, &p)) {
        //初始化插入结点
        BiTree s = (BiTree)malloc(sizeof(BiTNode));
        s->data = e;
        s->lchild = s->rchild = NULL;
        //如果 p 为NULL，说明该二叉排序树为空树，此时插入的结点为整棵树的根结点
        if (!p) {
            *T = s;
        }
        //如果 p 不为 NULL，则 p 指向的为查找失败的最后一个叶子结点，只需要通过比较 p 和 e 的值确定 s 到底是 p 的左孩子还是右孩子
        else if (e < p->data) {
            p->lchild = s;
        }
        else {
            p->rchild = s;
        }
        return TRUE;
    }
    //如果查找成功，不需要做插入操作，插入失败
    return FALSE;
}
~~~

二叉排序树的删除（有点复杂）

* 叶结点
* 有一颗子树的结点
* 有两颗子树的结点

~~~c
int Delete(BiTree *p)
{
    BiTree q, s;
    //情况 1，结点 p 本身为叶子结点，直接删除即可
    if (!(*p)->lchild && !(*p)->rchild) {
        *p = NULL;
    }
    else if (!(*p)->lchild) { //左子树为空，只需用结点 p 的右子树根结点代替结点 p 即可；
        q = *p;
        *p = (*p)->rchild;
        free(q);
    }
    else if (!(*p)->rchild) {//右子树为空，只需用结点 p 的左子树根结点代替结点 p 即可；
        q = *p;
        *p = (*p)->lchild;//这里不是指针 *p 指向左子树，而是将左子树存储的结点的地址赋值给指针变量 p
        free(q);
    }
    else {//左右子树均不为空，采用第 2 种方式
        q = *p;
        s = (*p)->lchild;
        //遍历，找到结点 p 的直接前驱
        while (s->rchild)
        {
            q = s;
            s = s->rchild;
        }
        //直接改变结点 p 的值
        (*p)->data = s->data;
        //判断结点 p 的左子树 s 是否有右子树，分为两种情况讨论
        if (q != *p) {
            q->rchild = s->lchild;//若有，则在删除直接前驱结点的同时，令前驱的左孩子结点改为 q 指向结点的孩子结点
        }
        else {
            q->lchild = s->lchild;//否则，直接将左子树上移即可
        }
        free(s);
    }
    return TRUE;
}
~~~

### AVL树

当我们构建二叉排序树的时候，假如输入的原序列原本就是有序的，按照普通的方法去构造的话会造成二叉树的严重倾斜，此时二叉树退化为链表。

因此，我们需要一种能够在二叉树的构建过程中动态的调整二叉排序树的结构，又不会破坏二叉树有序性的方法，这就是平衡二叉树方法。也叫AVL树

**原理**

平衡因子：根节点左子树和右子树的高度差就叫平衡因子，一般的，在平衡二叉树中根节点的平衡因子只能是1、-1、0三者之一，超出则需要进行平衡操作

在平衡二叉树中，我们定义两种操作，左旋和右旋

**左旋：**1.根的右子树的值载入根节点中 2.右子树的左子树变成根节点的右子树 3.整棵树左移，右子树变成根结点

**右旋：**1.根的左子树的值载入根节点中 2.左子树的右子树变成根节点的左子树 3.整棵树右移，左子树变成根结点

在平衡二叉树的创建过程中，不断的会有不平衡的情况出现，大致可分为四种情况，LL型、RR型、LR型、RL型，不同情况需要进行不同的左右旋操作

**LL型：**只需要执行一次右旋即可

**RR型：**只需要执行一次左旋即可

**LR型：**首先对失衡结点的左子树做一次左旋，再对失衡结点做一次右旋

**RL型：**首先对失衡结点的右树做一次左旋，再对失衡结点做一次左旋

### 红黑树

AVL树和红黑树都是自平衡二叉搜索树，它们都保证了树的高度是O(log n)级别的，因此在执行插入和删除等动态操作时，能够保证较好的时间复杂度。下面是它们的异同点：

相同点：

- 都是自平衡二叉搜索树，能够保证树的高度是O(log n)级别的。
- 都可以用于实现动态集合的操作，如插入、删除、查找等。

不同点：

- AVL树要求每个节点的左右子树高度差不超过1，因此在插入或删除节点时需要进行旋转操作来维护平衡。而红黑树则通过颜色标记来维护平衡，不需要像AVL树那样频繁旋转。
- 红黑树的平衡性能略逊于AVL树，但在插入和删除操作较多、查询操作较少的情况下，红黑树的性能更优。
- AVL树在进行插入和删除操作时需要进行更多次的旋转操作，因此相对于红黑树来说，它的实现比较复杂，且可能会带来较大的常数开销。
- 由于红黑树的实现比AVL树简单，因此在实际应用中，红黑树的使用更为广泛。

## 多路查找树

### B树

首先B-树是一种多路平衡搜索树

### B+树



## 哈希表-字典

当问题规模很大时，无论哪种查找都很慢，这时候要用根据关键码值的检索

**装填因子：**a=n/m，n是存储的结点数量，m是空间大小

用除留余数法产生关键码的时候会发生冲突，处理冲突的方法主要有两种

**闭散列法：**不是每一个地址都可以连接到元素

线性探测再散列

~~~c

~~~

二次探测再散列

~~~c

~~~

双重散列

~~~c

~~~

**开散列法**：每一个地址对所有元素都是开放的

 

