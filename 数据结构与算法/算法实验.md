## 01背包

有一个容量为V的背包，还有n个物体。现在忽略物体实际几何形状，我们认为只要背包的剩余容量大于等于物体体积，那就可以装进背包里。每个物体都有两个属性，即体积w和价值v。
问：如何向背包装物体才能使背包中物体的总价值最大？

具体的，假设背包容量范围在[0，15]，第i个物品对应的体积和价值分别为W[i]和v[i]。各种物品的价值和重量如下：

~~~
物品编号  1   2   3   4   5
重量W    3   4   7   8   9
价值V    4   5   10  11  13
~~~

由于性质的问题，它无法用贪心算法解决，我们对其建模。想象一个矩阵，横坐标为背包当前装载的物品量。纵坐标是对i个物品做决策，即对物品i有两个选择——放入背包和不放入背包。

![](http://1.14.100.228:8002/images/2022/04/15/20220415194857.png)

此时状态转移方程如上图所示，$f(i,j)$表示背包剩余容量为就j时，对第i件物品进行决策后背包内总价值为多少，其中$f(k-1,w)$表示不拿走第k-1个物品，$f(k-1, w-w_{k})+v_{k}$表示拿走第k个物品，当拿不下时，$f(k-1,w)=f(k-1, w-w_{k})+v_{k}$

这里提供最基础代码，有C和C++两个版本

C代码

~~~c
#include "stdio.h"
#include "stdlib.h"

#define max(N1, N2) N1>N2?N1:N2

int main() {
    /*
    第一行输入背包容量V和物体的个数n
    接下来有n行，每行包含两个数字，分别为该物体的花费和价值
    输入样例1:
     15 5 3 4 4 5 7 10 8 11 9 13
    */
    int V, n;//V背包容量，n物体数
    scanf("%d %d", &V, &n);
    //w为花费，v为价值
    int *w = (int *) malloc(sizeof(int) * (n + 1));
    int *v = (int *) malloc(sizeof(int) * (n + 1));
    int f[n + 1][V + 1];//f状态矩阵
    w[0] = 0;
    v[0] = 0;
    //输入原始数据
    for (int i = 1; i <= n; ++i) {
        int cur_w, cur_v;
        scanf("%d %d", &cur_w, &cur_v);
        w[i] = cur_w;
        v[i] = cur_v;
    }
    //初始化状态矩阵(初始化第一行就可以)
    for (int i = 0; i <= V; ++i) {
        f[0][i] = 0;
    }
    //动态规划过程(重点在这里)
    for (int i = 1; i <= n; ++i) {
        for (int j = V; j >= 0; j--) {
            if (j >= w[i]) {
                // 如果背包容量j大于第i个物品的重量w[i]，就要考虑是否将这个收入这个物品
                f[i][j] = max(f[i - 1][j], f[i - 1][j - w[i]] + v[i]);
            } else {
                // 如果背包容量j小于第i个物品的重量w[i]，那么背包价值和没有收入这个物品是一样的
                f[i][j] = f[i - 1][j];
            }
        }
    }
    //输出答案
    int ans = f[n][V];
    printf("%d", ans);
    return 0;
}
~~~

C++代码

~~~c++
#include <iostream>
#include <vector>
using namespace std;
#define max(N1,N2) N1>N2?N1:N2
int main()
{
	/*
	第一行输入背包容量V和物体的个数n
	接下来有n行，每行包含两个数字，分别为该物体的花费和价值
	输入样例1:
	 15 5
	 3 4 4 5 7 10 8 11 9 13
	*/
	vector<int> w, v;//w为花费，v为价值
	vector<vector<int>> f;//f状态矩阵
	int V, n;//V背包容量，n物体数
	while (cin >> V >> n){
		w.clear();
		v.clear();
		f.clear();
		w.push_back(0);
		v.push_back(0);
		//输入原始数据
		for (int i = 1; i <= n; i++){
			int cur_w, cur_v;
			cin >> cur_w >> cur_v;
			w.push_back(cur_w);
			v.push_back(cur_v);
		}
		//初始化状态矩阵
		for (int i = 0; i <= n; i++){
			vector<int> buff(V + 1, 0);
			f.push_back(buff);
		}
		//动态规划过程(重点在这里)
		for (int i = 1; i <= n; i++){
			for (int j = V; j >= 0; j--){
				if (j >= w[i]){
				    // 如果背包容量j大于第i个物品的重量w[i]，就要考虑是否将这个收入这个物品
					f[i][j] = max(f[i - 1][j], f[i - 1][j - w[i]] + v[i]);
				}
				else{
				    // 如果背包容量j小于第i个物品的重量w[i]，那么背包价值和没有收入这个物品是一样的
					f[i][j] = f[i - 1][j];
				}
			}
		}
		//输出答案
		int ans = f[n][V];
		cout << ans << endl;
	}
	return 0;
}
~~~



























