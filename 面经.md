# 引言

以下是一些prompts

~~~bash
用拓扑排序的思想补全下面的代码，要实现注释的要求，可以构建函数，也可以不构建，注意代码效率，输入n,m都有可能是10的5次方量级
~~~

回忆做算法题的一般思路：

**从题目获取信息**

看数据范围，估算方法的性能要求，能够给用什么算法一些思路

<img src="https://pic1.zhimg.com/80/v2-d1998396ae9e6ef1f41ba8c801211d25_720w.webp?source=1940ef5c" alt="img" style="zoom:67%;" />

<img src="https://picx.zhimg.com/80/v2-111753d89f2fef2f872d3f960997efe6_720w.webp?source=1940ef5c" alt="img" style="zoom: 80%;" />

## 美团笔试（第一场）

第一题：暴力解

~~~bash
题目描述：
小美在玩一项游戏。该游戏的目标是尽可能抓获敌人。
敌人的位置将被一个二维坐标 (x, y) 所描述。
小美有一个全屏技能，该技能能一次性将若干敌人一次性捕获。
捕获的敌人之间的横坐标的最大差值不能大于A，纵坐标的最大差值不能大于B。
现在给出所有敌人的坐标，你的任务是计算小美一次性最多能使用技能捕获多少敌人。
输入描述：
第一行三个整数N,A,B，表示共有N个敌人，小美的全屏技能的参数A和参数B。
接下来N行，每行两个数字x,y，描述一个敌人所在的坐标。
1≤N≤500，1≤A,B≤1000，1≤x,y≤1000。
输出描述：
一行，一个整数表示小美使用技能单次所可以捕获的最多数量。

样例输入1
3 1 1
1 1
1 2
1 3
样例输出1
2
样例输入2
5 1 2
1 1
2 2
3 3
1 3
1 4
样例输出2
3
~~~

我的方案

~~~python
N, A, B = map(int, input().split())
enemies = []
for i in range(N):
    x, y = map(int, input().split())
    enemies.append((x, y))

max_enemies = 0

for i in range(N):
    captive_enemies = [(enemies[i][0], enemies[i][1])]
    for j in range(i + 1, N):
        captive = False
        for k in range(len(captive_enemies)):
            if abs(enemies[j][0] - captive_enemies[k][0]) <= A and abs(enemies[j][1] - captive_enemies[k][1]) <= B:
                captive = True
            else:
                captive = False
                break
        if captive == True:
            captive_enemies.append((enemies[j][0], enemies[j][1]))
    max_enemies = max(max_enemies, len(captive_enemies))

print(max_enemies)
~~~



第二题，双指针滑动窗口

~~~bash
题目描述：
小美现在有一串彩带，假定每一厘米的彩带上都是一种色彩。
因为任务的需要，小美希望从彩带上截取一段，使得彩带中的颜色数量不超过K种。
显然，这样的截取方法可能非常多。于是小美决定尽量长地截取一段。
你的任务是帮助小美截取尽量长的一段，使得这段彩带上不同的色彩数量不超过K种。
输入描述：
第一行两个整数N,K，以空格分开，分别表示彩带有N厘米长，你截取的一段连续的彩带不能超过K种颜色。
接下来一行N个整数，每个整数表示一种色彩，相同的整数表示相同的色彩。
1≤N,K≤5000，彩带上的颜色数字介于[1, 2000]之间。
输出描述：
一行，一个整数，表示选取的彩带的最大长度。

样例输入1
8 3
1 2 3 2 1 4 5 1
样例输出1
5
样例解释1
最长的一段彩带是[1, 2, 3, 2, 1]，共5厘米。
~~~

我的方案

~~~python
n, k = map(int, input().split())
colors = list(map(int, input().split()))
#i,j表示截取的彩带的头尾指针
i, j = 0, 0
#count表示颜色的种类数量
count = 0
color_count = {}
max_len = 0

while j < n:
    if colors[j] not in color_count:
        color_count[colors[j]] = 1
        count += 1
    else:
        color_count[colors[j]] += 1

    while count > k:
        color_count[colors[i]] -= 1
        if color_count[colors[i]] == 0:
            count -= 1
            del color_count[colors[i]]
        i += 1

    max_len = max(max_len, j - i + 1)
    j += 1

print(max_len)
~~~

第三题，字符串操作，递归

~~~bash
题目描述：
现在小美获得了一个字符串。小美想要使得这个字符串是回文串。
小美找到了你。你可以将字符串中至多两个位置改为任意小写英文字符’a’-‘z’。
你的任务是帮助小美在当前制约下，获得字典序最小的回文字符串。
数据保证能在题目限制下形成回文字符串。
注：回文字符串：即一个字符串从前向后和从后向前是完全一致的字符串。
例如字符串abcba, aaaa, acca都是回文字符串。字符串abcd, acea都不是回文字符串。
输入描述：
一行，一个字符串。字符串中仅由小写英文字符构成。
保证字符串不会是空字符串。
字符串长度介于 [1, 100000] 之间。
输出描述：
一行，一个在题目条件限制下所可以获得的字典序最小的回文字符串。

样例输入1
acca
样例输出1
aaaa
样例解释1
原来的字符串已经是回文字符串了。但它不是题目条件下可以取得的字典序最小的回文字符串。将第二个字符和第三个字符都改为a可以获得字典序最小的回文字符串。
样例输入2
abcde
样例输出2
abcba
样例解释1
将de改为ba可以获得字典序最小的回文字符串
~~~

我的方案

~~~python
def recursive_palindrome(s):
    if s == s[::-1]:
        return s
    else:
        n = len(s)
        for i in range(n // 2):
            if s[i] != s[n - i - 1]:
                # 尝试将左边或右边的字符改为和对应的字符相同
                left = s[:i] + s[n - i - 1] + s[i + 1:]
                right = s[:n - i - 1] + s[i] + s[n - i:]
                # 检查修改后的字符串能否构成回文串
                if left == left[::-1] and left < right:
                    return left
                elif right == right[::-1] and right < left:
                    return right
                else:
                    left = recursive_palindrome(left)
                    right = recursive_palindrome(right)
                    return left if left < right else right


def make_palindrome(s):
    if s == s[::-1]:
        # 如果原字符串已经是回文串
        # 检查能否通过同时更改字符串两边的字符，使字符串字典序最小
        n = len(s)
        for i in range(n // 2):
            if s[i] != 'a':
                return s[:i] + 'a' + s[i + 1: len(s) - i - 1] + 'a' + s[len(s) - i:]
        return 'a' * n
    else:
        return recursive_palindrome(s)


s = input().strip()
n = len(s)
print(make_palindrome(s))
~~~

第四题，动态规划

~~~bash
题目描述：
现在商店里有N个物品，每个物品有原价和折扣价。
小美想要购买商品。小美拥有X元，一共Y张折扣券。
小美需要最大化购买商品的数量，并在所购商品数量尽量多的前提下，尽量减少花费。
你的任务是帮助小美求出最优情况下的商品购买数量和花费的钱数。
输入描述：
一行，一个字符串。字符串中仅由小写英文字符构成。
保证字符串不会是空字符串。
字符串长度介于 [1, 100000] 之间。
输出描述：
第一行三个整数，以空格分开，分别表示N,X,Y。
接下来N行，每行两个整数，以空格分开，表示一个的原价和折扣价。
1≤N≤100, 1≤X≤5000, 1≤Y≤50，每个商品原价和折扣价均介于[1,50]之间。

样例输入1
3 5 1
4 3
3 1
6 5
样例输出1
2 5
样例解释1
第一个商品原价购入，第二个商品折扣价购入，可以获得最多的商品数量2个。
此时消耗5元。因此输出 2 5。
样例输入2
3 5 1
4 3
3 1
6 1
样例输出2
2 4
样例解释2
可以发现有很多种买两个商品的方法。
最省钱的方案是第二个商品原价购入，第三个商品折扣价购入。此时花费4元。
样例输入3
10 30 3
2 1
3 2
2 1
10 8
6 5
4 3
2 1
10 9
5 4
4 2
样例输出3
8 24
~~~

我的方案（错误）

~~~python
# 动态规划解决小美购物问题
# 定义dp[i][j][k]表示前i个物品，花费j元，使用k张折扣券的最大购买数量
# 状态转移方程为dp[i][j][k]=max(dp[i-1][j][k], dp[i-1][j-price[i]][k-1]+1, dp[i-1][j-discount[i]][k]+1)
# 其中price[i]表示第i个物品的原价，discount[i]表示第i个物品的折扣价
# 最终答案为dp[N][X][Y]
# 读取输入
line = sys.stdin.readline().strip()
n, x, y = map(int, line.split())
prices = []
discounts = []
for i in range(n):
    line = sys.stdin.readline().strip()
    price, discount = map(int, line.split())
    prices.append(price)
    discounts.append(discount)

# 初始化dp数组
dp = [[[0 for _ in range(y+1)] for _ in range(x+1)] for _ in range(n+1)]

# 动态规划
for i in range(1, n+1):
    for j in range(1, x+1):
        for k in range(y+1):
            dp[i][j][k] = dp[i-1][j][k]
            if j >= prices[i-1] and k >= 1:
                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-prices[i-1]][k-1]+1)
            if j >= discounts[i-1] and k >= 1:
                dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-discounts[i-1]][k]+1)

# 找到最大购买数量和最小花费
max_num = 0
min_cost = float('inf')
for j in range(x+1):
    for k in range(y+1):
        if dp[n][j][k] > max_num:
            max_num = dp[n][j][k]
            min_cost = j
        elif dp[n][j][k] == max_num:
            min_cost = min(min_cost, j)

print(max_num, min_cost)
~~~

第五题，图节点的辐射范围

~~~bash
用python代码解题，给出详细注释
题目描述：
现在有若干节点。每个节点上有能量塔。所有节点构成一个图。
某个节点u可以为和u距离不超过给定值的节点各提供一点能量。
此处距离的定义为两个节点之间经过的边的数量。特别的，节点u到本身的距离为零。
现在给出每个节点上的能量塔可以为多远的距离内的点提供能量。
小美想要探究每个节点上的能量值具体是多少。你的任务是帮助小美计算得到，并依次输出。
输入描述：
第一行一个整数N，表示节点的数量。
接下来一行N个以空格分开的整数，依次表示节点1，节点2，…，节点N的能量塔所能提供能量的最远距离。
接下来N-1行，每行两个整数，表示两个点之间有一条边。
1≤N≤500，节点上能量塔所能到达的最远距离距离不会大于 500.
输出描述：
一行N个整数，依次表示节点1，节点2，…，节点N上的能量值。

样例输入1
3
1 1 1
1 2
2 3
样例输出1
2 3 2
样例解释1
节点1上的能量塔可以为节点1和2提供能量。
节点2上的能量塔可以为节点1、2和3提供能量。
节点3上的能量塔可以为节点2和3提供能量。
样例输入2
10
1 2 1 1 1 2 3 1 1 1
1 2
2 3
1 4
2 5
4 6
3 7
5 8
1 9
2 10
样例输出2
6 6 3 4 4 2 3 3 3 3
~~~

我的方案

~~~python
#模拟能力在图上传播的过程，就是暴力解
def dfs(node, energy, visited, graph, dist, limit):
    visited[node] = True
    for neighbor in graph[node]:
        if not visited[neighbor]:
            # 如果能量塔覆盖范围可以到达该相邻节点
            if dist[node][neighbor] <= limit:
                energy[neighbor] += 1
                dfs(neighbor, energy, visited, graph, dist, limit-1)

def get_energy_values(n, limits, edges):
    graph = [[] for _ in range(n)]
    # 遍历所有边的关系，构建图 graph[i][j] 表示第i个点和第j个点的联通关系
    for i in range(n-1):
        u, v = edges[i]
        graph[u-1].append(v-1)
        graph[v-1].append(u-1)

    # 计算节点之间的距离, dist[i][j]表示第i个节点和第j个节点的距离
    dist = [[0] * n for _ in range(n)]
    for i in range(n):
        visited = [False] * n
        stack = [(i, 0)]
        while stack:
            node, d = stack.pop()
            if visited[node]:
                continue
            visited[node] = True
            dist[i][node] = d
            for neighbor in graph[node]:
                stack.append((neighbor, d+1))
    energy = [1] * n
    # 遍历每个节点，计算能量值
    for i in range(n):
        visited = [False] * n
        dfs(i, energy, visited, graph, dist, limits[i])
    return energy

# 读入输入
n = int(input())
limits = list(map(int, input().split()))
edges = []
for _ in range(n-1):
    u, v = map(int, input().split())
    edges.append((u, v))

# 计算并输出节点能量值
energy = get_energy_values(n, limits, edges)
print(*energy)
~~~

## 美团笔试（第二场）



## OneFlow一面

狂问项目，以后要多熟悉再面试了，不要浪费机会

c++八股：

1. 函数的指针传参和引用传参有什么区别
2. 智能指针有哪些，什么作用
3. 内存分配的方法
4. new的一种方法，也叫原地构造，右值引用的一种应用



## 腾讯音乐笔试

**第一题**

二叉树有n个节点，将所有节点赋值为1到n的正整数，没有两个节点的值相等。需要满足：奇数层的权值和与偶数层的权值和之差的绝对值不超过1

~~~python
class TreeNode:
    def __init__(self, val=-1, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def __init__(self):
        self.total = 0

    # 得到树的节点的数量
    def get_total_nodes(self, root):
        if root is None:
            return 0
        return 1 + self.get_total_nodes(root.left) + self.get_total_nodes(root.right)

    # 填充树节点的val，使奇数层的权值和与偶数层的权值和之差的绝对值不超过1
    def fill_node_vals(self, root, is_odd, total, curr):
        if root is None:
            return 0

        left_count = self.fill_node_vals(root.left, not is_odd, total, curr)
        right_count = self.fill_node_vals(root.right, not is_odd, total, curr)

        if is_odd:
            root.val = 2 * curr + left_count - right_count
        else:
            root.val = -2 * curr + total - left_count + right_count

        return 1 + left_count + right_count

    # 验证树是否满足奇数层的权值和与偶数层的权值和之差的绝对值不超过1
    def is_valid(self, root):
        if root is None:
            return True

        left_sum = self.get_sum(root.left, True)
        right_sum = self.get_sum(root.right, False)

        if abs(left_sum - right_sum) > 1:
            return False

        return self.is_valid(root.left) and self.is_valid(root.right)

    # 获取给定树中奇数层或偶数层的权值和
    def get_sum(self, root, is_odd):
        if root is None:
            return 0

        if is_odd:
            return root.val + self.get_sum(root.left, not is_odd) + self.get_sum(root.right, not is_odd)
        else:
            return -root.val + self.get_sum(root.left, not is_odd) + self.get_sum(root.right, not is_odd)

    def fun(self, root: TreeNode) -> TreeNode:
        self.total = self.get_total_nodes(root)
        self.fill_node_vals(root, True, self.total, 0)

        if self.is_valid(root):
            return root
        else:
            return TreeNode(0)


solution = Solution()
#输入的树权值初始化为-1
root = TreeNode(-1, TreeNode(-1, TreeNode(-1), TreeNode(-1)), TreeNode(-1))
solution.fun(root)
~~~

**第二题**

小红定义一个字符串的权值为：字符串长度乘以字符串的字母种类数量。小红拿到一个字符串，她准备将该字符串切分成k个子串。小红希望切分后这k个子串的最大权值尽可能小，用python解题，只需要**返回这k个子串的最大权值**即可

~~~python
# 计算区间内不同字母的数量
def char_count(s, l, r):
    return len(set(s[l - 1:r]))

def max_weight(s, k):
    n = len(s)
    # 初始化边界条件
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
    for i in range(1, n + 1):
        dp[i][1] = i * char_count(s, 1, i)
    # 递推计算状态, dp[i][j]表示当字符串长度为i，分割次数为j时最优的字符串总长度
    flag = False
    result = [[[0, 0]] * (k + 1) for _ in range(n + 1)]
    for i in range(2, n + 1):
        for j in range(2, k + 1):
            for p in range(j - 1, i):
                temp = dp[i][j]
                dp[i][j] = min(dp[i][j], dp[p][j - 1] + (i - p) * char_count(s, p + 1, i))
                if temp != dp[i][j]:
                    # 因为是加法必定是两端最优才能总体最优
                    result[i][j] = [p, j - 1]
    # 通过记录每一个步骤的最优和最优结构，反推出各个字串的长度
    x, y = n, k
    sub_lens = []
    while True:
        _x, _y = result[x][y]
        sub_lens.append(dp[x][y] - dp[_x][_y])
        x, y = result[x][y]
        if result[x][y] == [0, 0]:
            sub_lens.append(dp[x][y])
            break

    return max(sub_lens)
~~~

**第三题**

小红拿到了一个仅由大写字母和小写字母组成的字符串。她想知道，在不考虑大小写的情况下，有多少对相邻的字母相等？

~~~python
def count_adjacent_pairs(s):
    count = 0
    for i in range(len(s) - 1):
        if s[i].lower() == s[i+1].lower():
            count += 1
    return count
~~~

**第四题（场景）**

设计一个在线号码包上传以及查询系统，把一个含有大量用户ID的文件（超过1亿），快速上传到该服务，考虑上传方案、存储方案、需要保障查询效率（并发QPS 10W/s，时延20ms以内）（如果要推导，可以手写到草稿纸上）

~~~bash
假定在线号码包内含表格数据[手机号码, 地区, 运营商]
上传方案：
分多少片传，如何分片，用什么协议上传，如何确保上传过程的稳定性和可靠性。
存储方案：
肯定要采用分布式存储系统来存储用户ID数据，用什么架构，如何优化
查询效率保障（推导过程）：
1.以Hbase为例，如果合理建表，使用HBase的过滤器（Filter）来减少数据的扫描范围，合理调整Region的大小，在10台服务器（24 核CPU、64GB内存、10Gbps网络带宽）的情况下，可以达到并发QPS 10W/s以上，时延20ms以内。
2.Redis Cluster为例，如果合理建立索引，在10台服务器（16 核CPU、64GB内存、1Gbps网络带宽）的情况下，可以达到并发QPS 10W/s以上，时延20ms以内。
~~~



## 蚂蚁集团笔试

**坠落的蚂蚁**

~~~cpp
#include<iostream>
#include<algorithm>
 
using namespace std;
const int N = 102;
 
int aa[N],bb[N];        //left蚂蚁位置 right蚂蚁位置
int a[N],b[N];
int main()
{
	int n;
	while(cin>>n)
	{
		int pos=0;              //蚂蚁A位置
		for(int i=1;i<=n;++i)
		{
			cin>>a[i]>>b[i];
			if(b[i]==0) pos=a[i];
		}
		int nl=0,nr=0;
		for(int i=1;i<=n;++i)
		{
			if(a[i]<pos && b[i]>0) aa[++nl]=100-a[i];
			else if(a[i]>pos && b[i]<0) bb[++nr]=a[i];
		}
		if(nl==nr) cout<<"Cannot fall!"<<endl;
		else if(nl>nr)
		{
			sort(aa+1,aa+nl+1);
			cout<<aa[nr+1]<<endl;
		}
		else
		{
			sort(bb+1,bb+nr+1);
			cout<<bb[nl+1]<<endl;
		}
	}
	return 0;
}
~~~

**蚂蚁森林之王**

~~~python
n = int(input())
nums = list(map(int, input().split()))
length = len(nums)
dic = {}

for i in range(length - 1, -1, -1):
    id = i + 1
    if id in dic:
        dic[id] += 1
    else:
        dic[id] = 1
    if nums[i] != 0:
        if nums[i] in dic:
            dic[nums[i]] = dic[nums[i]] + dic[id]
        else:
            dic[nums[i]] = dic[id]

for k in sorted(dic):
    print(dic[k])
~~~

**碰撞的蚂蚁**

~~~java
import java.util.*;

public class Ants {
    public double antsCollision(int n) {
        //所有蚂蚁同向时不会发生碰撞
     	return 1-Math.pow(0.5, n-1);   
    }
}
~~~



