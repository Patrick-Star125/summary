回忆做算法题的一般思路：

**从题目获取信息**

看数据范围，估算方法的性能要求，能够给用什么算法一些思路

<img src="https://pic1.zhimg.com/80/v2-d1998396ae9e6ef1f41ba8c801211d25_720w.webp?source=1940ef5c" alt="img" style="zoom:67%;" />

<img src="https://picx.zhimg.com/80/v2-111753d89f2fef2f872d3f960997efe6_720w.webp?source=1940ef5c" alt="img" style="zoom: 80%;" />

## 美团

### 2023春季后端实习笔试

第一题：暴力解

~~~bash
题目描述：
小美在玩一项游戏。该游戏的目标是尽可能抓获敌人。
敌人的位置将被一个二维坐标 (x, y) 所描述。
小美有一个全屏技能，该技能能一次性将若干敌人一次性捕获。
捕获的敌人之间的横坐标的最大差值不能大于A，纵坐标的最大差值不能大于B。
现在给出所有敌人的坐标，你的任务是计算小美一次性最多能使用技能捕获多少敌人。
输入描述：
第一行三个整数N,A,B，表示共有N个敌人，小美的全屏技能的参数A和参数B。
接下来N行，每行两个数字x,y，描述一个敌人所在的坐标。
1≤N≤500，1≤A,B≤1000，1≤x,y≤1000。
输出描述：
一行，一个整数表示小美使用技能单次所可以捕获的最多数量。

样例输入1
3 1 1
1 1
1 2
1 3
样例输出1
2
样例输入2
5 1 2
1 1
2 2
3 3
1 3
1 4
样例输出2
3
~~~

我的方案

~~~python
N, A, B = map(int, input().split())
enemies = []
for i in range(N):
    x, y = map(int, input().split())
    enemies.append((x, y))

max_enemies = 0

for i in range(N):
    captive_enemies = [(enemies[i][0], enemies[i][1])]
    for j in range(i + 1, N):
        captive = False
        for k in range(len(captive_enemies)):
            if abs(enemies[j][0] - captive_enemies[k][0]) <= A and abs(enemies[j][1] - captive_enemies[k][1]) <= B:
                captive = True
            else:
                captive = False
                break
        if captive == True:
            captive_enemies.append((enemies[j][0], enemies[j][1]))
    max_enemies = max(max_enemies, len(captive_enemies))

print(max_enemies)
~~~



第二题，双指针滑动窗口

~~~bash
题目描述：
小美现在有一串彩带，假定每一厘米的彩带上都是一种色彩。
因为任务的需要，小美希望从彩带上截取一段，使得彩带中的颜色数量不超过K种。
显然，这样的截取方法可能非常多。于是小美决定尽量长地截取一段。
你的任务是帮助小美截取尽量长的一段，使得这段彩带上不同的色彩数量不超过K种。
输入描述：
第一行两个整数N,K，以空格分开，分别表示彩带有N厘米长，你截取的一段连续的彩带不能超过K种颜色。
接下来一行N个整数，每个整数表示一种色彩，相同的整数表示相同的色彩。
1≤N,K≤5000，彩带上的颜色数字介于[1, 2000]之间。
输出描述：
一行，一个整数，表示选取的彩带的最大长度。

样例输入1
8 3
1 2 3 2 1 4 5 1
样例输出1
5
样例解释1
最长的一段彩带是[1, 2, 3, 2, 1]，共5厘米。
~~~

我的方案

~~~python
n, k = map(int, input().split())
colors = list(map(int, input().split()))
#i,j表示截取的彩带的头尾指针
i, j = 0, 0
#count表示颜色的种类数量
count = 0
color_count = {}
max_len = 0

while j < n:
    if colors[j] not in color_count:
        color_count[colors[j]] = 1
        count += 1
    else:
        color_count[colors[j]] += 1

    while count > k:
        color_count[colors[i]] -= 1
        if color_count[colors[i]] == 0:
            count -= 1
            del color_count[colors[i]]
        i += 1

    max_len = max(max_len, j - i + 1)
    j += 1

print(max_len)
~~~



第三题，字符串操作，递归

~~~bash
题目描述：
现在小美获得了一个字符串。小美想要使得这个字符串是回文串。
小美找到了你。你可以将字符串中至多两个位置改为任意小写英文字符’a’-‘z’。
你的任务是帮助小美在当前制约下，获得字典序最小的回文字符串。
数据保证能在题目限制下形成回文字符串。
注：回文字符串：即一个字符串从前向后和从后向前是完全一致的字符串。
例如字符串abcba, aaaa, acca都是回文字符串。字符串abcd, acea都不是回文字符串。
输入描述：
一行，一个字符串。字符串中仅由小写英文字符构成。
保证字符串不会是空字符串。
字符串长度介于 [1, 100000] 之间。
输出描述：
一行，一个在题目条件限制下所可以获得的字典序最小的回文字符串。

样例输入1
acca
样例输出1
aaaa
样例解释1
原来的字符串已经是回文字符串了。但它不是题目条件下可以取得的字典序最小的回文字符串。将第二个字符和第三个字符都改为a可以获得字典序最小的回文字符串。
样例输入2
abcde
样例输出2
abcba
样例解释1
将de改为ba可以获得字典序最小的回文字符串
~~~

我的方案

~~~python
def recursive_palindrome(s):
    if s == s[::-1]:
        return s
    else:
        n = len(s)
        for i in range(n // 2):
            if s[i] != s[n - i - 1]:
                # 尝试将左边或右边的字符改为和对应的字符相同
                left = s[:i] + s[n - i - 1] + s[i + 1:]
                right = s[:n - i - 1] + s[i] + s[n - i:]
                # 检查修改后的字符串能否构成回文串
                if left == left[::-1] and left < right:
                    return left
                elif right == right[::-1] and right < left:
                    return right
                else:
                    left = recursive_palindrome(left)
                    right = recursive_palindrome(right)
                    return left if left < right else right


def make_palindrome(s):
    if s == s[::-1]:
        # 如果原字符串已经是回文串
        # 检查能否通过同时更改字符串两边的字符，使字符串字典序最小
        n = len(s)
        for i in range(n // 2):
            if s[i] != 'a':
                return s[:i] + 'a' + s[i + 1: len(s) - i - 1] + 'a' + s[len(s) - i:]
        return 'a' * n
    else:
        return recursive_palindrome(s)


s = input().strip()
n = len(s)
print(make_palindrome(s))
~~~



第四题，动态规划

~~~bash
题目描述：
现在商店里有N个物品，每个物品有原价和折扣价。
小美想要购买商品。小美拥有X元，一共Y张折扣券。
小美需要最大化购买商品的数量，并在所购商品数量尽量多的前提下，尽量减少花费。
你的任务是帮助小美求出最优情况下的商品购买数量和花费的钱数。
输入描述：
一行，一个字符串。字符串中仅由小写英文字符构成。
保证字符串不会是空字符串。
字符串长度介于 [1, 100000] 之间。
输出描述：
第一行三个整数，以空格分开，分别表示N,X,Y。
接下来N行，每行两个整数，以空格分开，表示一个的原价和折扣价。
1≤N≤100, 1≤X≤5000, 1≤Y≤50，每个商品原价和折扣价均介于[1,50]之间。

样例输入1
3 5 1
4 3
3 1
6 5
样例输出1
2 5
样例解释1
第一个商品原价购入，第二个商品折扣价购入，可以获得最多的商品数量2个。
此时消耗5元。因此输出 2 5。
样例输入2
3 5 1
4 3
3 1
6 1
样例输出2
2 4
样例解释2
可以发现有很多种买两个商品的方法。
最省钱的方案是第二个商品原价购入，第三个商品折扣价购入。此时花费4元。
样例输入3
10 30 3
2 1
3 2
2 1
10 8
6 5
4 3
2 1
10 9
5 4
4 2
样例输出3
8 24
~~~

第五题，树

~~~bash
题目描述：
现在有若干节点。每个节点上有能量塔。所有节点构成一棵树。
某个节点u可以为和u距离不超过给定值的节点各提供一点能量。
此处距离的定义为两个节点之间经过的边的数量。特别的，节点u到本身的距离为零。
现在给出每个节点上的能量塔可以为多远的距离内的点提供能量。
小美想要探究每个节点上的能量值具体是多少。你的任务是帮助小美计算得到，并依次输出。
输入描述：
第一行一个整数N，表示节点的数量。
接下来一行N个以空格分开的整数，依次表示节点1，节点2，…，节点N的能量塔所能提供能量的最远距离。
接下来N-1行，每行两个整数，表示两个点之间有一条边。
1≤N≤500，节点上能量塔所能到达的最远距离距离不会大于 500.
输出描述：
一行N个整数，依次表示节点1，节点2，…，节点N上的能量值。

样例输入1
3
1 1 1
1 2
2 3
样例输出1
2 3 2
样例解释1
节点1上的能量塔可以为节点1和2提供能量。
节点2上的能量塔可以为节点1、2和3提供能量。
节点3上的能量塔可以为节点2和3提供能量。
样例输入2
10
1 2 1 1 1 2 3 1 1 1
1 2
2 3
1 4
2 5
4 6
3 7
5 8
1 9
2 10
样例输出2
6 6 3 4 4 2 3 3 3 3
~~~





