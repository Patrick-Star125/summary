# 面向对象

## 基本概念

java是一门纯面向对象的语言，以一个完整的例子来解释java如何设计类分层，如何抽象。

在java面向对象中，最核心的概念是类的继承，由于类的继承，在向新系统添加功能的时候只需要增加代码，而无需改动原本的代码，大大增强了维护性。

**继承树**

一个合理的类结构应当能够抽象为继承树的关系，例如下图

* 具体类是抽象类的实现
* 接口是抽象类的补充

![](http://pic.netpunk.top/images/2022/06/06/20220606122427.png)

- 构造器：`new`就是一个构造器，作用是：①分配空间；②赋初始值（避免错误，简化输入）；  
- `new Object(Parameters)`构造器调用构造函数，**传参**为了赋初始值；  
- 对象的基本元素是：**属性**和方法   类成员（属性和方法）。属性最为重要，属性的集合是一个状态，方法是一个状态到另一个状态的桥梁；
- 封装：属性和处理属性的方法集合起来。把数据及数据的操作方法放在一起，作为一个相互依存的整体，即对象。

面向对象是基于面向过程而言的，面向对象是将功能等通过对象来实现，将功能封装进对象之中，让对象去实现具体的细节；

这种思想是将数据作为第一位，而方法或者说是算法作为其次，这是对数据一种简化，操作起来更加的方便，简化了过程。

**封装：**把数据和方法包装进类中，以及具体实现的隐藏共同被称为**封装**。

![](http://pic.netpunk.top/images/2022/06/06/20220606132053.png)

## 继承

在一个子类被创建的时候

* 首先会在内存中创建一个父类对象
* 然后在父类对象外部放上子类独有的属性，两者合起来形成一个子类的对象。

例如

~~~java
class A extends B{
    public A(int a {
        super(a) //因为是先创建父类对象，因此都需要调用super，如果这里没有super jvm就会自动调用一次
    }
}
~~~

**继承使子类拥有父类所有的属性和方法**，但是父类对象中的私有属性和方法，子类是无法访问到的，只是拥有，但不能使用。

**子类不能继承父类的构造函数，只是显式或隐式调用**，可以从子类调用超类的构造函数。

父类定义了有参的构造函数后，可以不定义无参的构造函数，系统也不会提供默认的无参构造函数。这时子类**只能调用父类的有参构造函数**。

**注意：**除非两个类之间是“`is - a`”的关系，否则不要轻易地使用继承。过多的使用继承会破坏代码的可维护性，当父类修改时，会影响所有继承他的子类，增加了程序维护的难度和成本。

**构造函数**

1. 构造函数不能被继承，不能被覆盖，能被重载
2. 父类和子类都没有定义构造函数时，编译器都会为父类生成一个默认的无参构造，给子类也生成一个默认的无参的构造函数
3. 构造方法会在成员变量之后初始化
4. 构造方法不能被`static`、`final`、`synchronize`、`abstract`、`native`修饰，但可以被`public`、`private`、`protect`修饰

在继承的时候，父类当然也有构造方法，如果你要创建子类的对象，那么执行的过程**首先是调用父类的无参构造方法生成父类的对象，然后再调用子类的无参构造方法来生成子类对象。继承的时候都是先生成父类的对象，然后再生成子类的对象。**

<img src="http://pic.netpunk.top/images/2022/01/14/20220114223240.png" style="zoom:50%;" />

1. 什么是继承？

继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

2. 什么时候要用继承？

当类与类之间存在`is -a`的关系的时候就可以使用继承，实现代码复用，提高代码可读性和维护性。

3. 如何实现继承？

继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 **java.lang** 包中，所以不需要 **import**）祖先类。



## 重写和重载

方法重载（`overload`）：

- 必须是同一个类；
- 方法名（也可以叫函数）一样；
- 参数类型不一样或参数数量或顺序不一样；

方法的重写（`override`）子类重写了父类的同名方法，两同两小一大原则：

- 方法名相同，参数类型相同；
- 子类返回类型是父类返回类型的子类；
- 子类抛出异常小于等于父类方法抛出异常；
- 子类访问权限大于等于父类方法访问权限。

## 抽象类

- 用`abstract`修饰的类表示**抽象类**，抽象类位于继承树的抽象层，抽象类不能被实例化。
- 用`abstract`修饰的方法表示**抽象方法**，抽象方法没有方法体。抽象方法用来描述系统具有什么功能，但不提供具体的实现，把具体实现留给继承该类的子类。

~~~java
abstract public class A {
    abstract B(){}
}
~~~

抽象类特点：

- 含有抽象方法的类必须声明为抽象类（不管其中是否有其他方法）；
- 抽象类可以没有抽象方法，可以有普通方法；
- 抽象类必须被继承，抽象方法必须被重写（若子类还是抽象类，不需要重写）；
- 抽象类不能被实例化（不能直接构造一个该类的对象）。

抽象方法特点：

- 在类中没有方法体（抽象方法只需声明，而不需实现某些功能）；
- 抽象类中的抽象方法必须被实现；
- 如果一个子类没有实现父类中的抽象方法，则子类也变成了一个抽象类。

## 接口

* `interface` 中的方法默认为`public abstract`
* 变量默认为`public static final`
* 类中的方法全部都是抽象方法。只有声明没有实现，在不同类中有不同的方法实现。

不同点：

- 接口中只能包含抽象方法和默认方法，不能为普通方法提供方法实现；抽象类中可以包含普通方法；
- 接口里不能定义静态方法（`jdk1.8`下可以定义`static`方法），抽象类可以定义静态方法；
- 接口中只能定义静态常量，不能定义普通成员变量；抽象类即可以定义变量又可以定义静态常量；
- 接口中不包含构造器，抽象类里可以包含构造器，抽象类中的构造器并不是用于创建对象，而是让其他子类调用这些构造器来完成抽象类的初始化操作；
- 接口里不能包含初始化块，但抽象类可以包含；
- 一个类最多只能有一个父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足。

共同点：

- 接口和抽象类都不能被实例化，都位于继承树的顶端，用于被其他类实现的继承；
- 接口和抽象类都可以包含抽象方法，实现接口和继承抽象类的普通子类都必须实现这些方法。

![img](https://data.educoder.net/api/attachments/206834)

1. 什么是接口？

接口是一种抽象类型，是抽象方法的集合，位于继承树的顶端，类继承接口后需要按照接口规定的格式实现抽象方法。

2. 什么应用场景下需要使用接口？

接口可以用于不同类实现相同行为，例如有类A、B分别继承不同的抽象类，但是都有一个相同的行为C，此时接口D包含行为C，A、B就能够一起实现接口D，增强了代码的结构性。

3. 请给出示例代码，说明如何定义和实现 Java 接口？

~~~java
public interface A {
    public void A1();
    public void A2();
}

class B implements A {
    public A1(){
        System.out.println("this is A1");
    }
    
    public A2(){
        System.out.println("this is A2");
    }
}
~~~

上面的代码定义了接口A，类B实现了接口A中定义的抽象函数

一个类可以同时继承多个接口，此时需要实现多个接口的方法

~~~java
public interface C implements A,B{}
~~~

## 关键字

### final

- `final`修饰的**类**，就是最终类，不能被继承。
- `final`修饰的**方法**，就是最终方法，最终方法不能被**重写**。
- `final`修饰一个**引用变量**时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。修饰**基本数据类型**变量时，内容不能变。
- `final`成员变量必须在初始化代码块或在构造器中初始化。

**作用**

- `final`类：如果一个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会再被扩展，那么就设计成`final`类。
- `final`方法：①把方法锁定，防止任何继承类修改它的意义和实现。②高效，编译器在遇到调用`final`方法时候会转入内嵌机制，大大提升执行效率。

### static

**静态变量**

* `static`修饰的变量称为静态变量，静态变量属于整个类，而局部变量属于方法，只在该方法内有效。
* `static`不能修饰局部变量。`static`方法内部不能调用非静态方法。
* 静态变量只能在类主体中定义，不能在方法中定义。
* `static`变量只会创建一份，不管创建几个对象，都共用一个变量。

**静态方法**

* **类方法**指被`static`修饰的方法，无`this`指针。类方法可以调用其他类的`static`方法。
* 类方法和对象方法的区别：
  * 类方法是属于整个类的，而实例方法是属于类的某个对象的。由于类方法是属于整个类的，并不属于类的哪个对象，所以类方法的方法体中不能有与类的对象有关的内容。
    * 类方法中不能引用对象变量；
    * 类方法中不能调用类的对象方法；
    * 在类方法中不能使用`super`、`this`关键字。（因为this是对象实例化以后才有的）
    * 类方法不能被覆盖。

**作用**

- 为某特定数据类型或对象分配单一的存储空间，而与创建对象的个数无关；实现某个方法或属性与类而不是对象关联在一起；
- 静态变量属于类，在内存中只有一个复制，只要静态变量所在的类被加载，这个静态变量就会被分配空间。









































