二阶段锁是一种悲观的并发控制机制，表现在其思想：为了防止未来可能的并发冲突，现在就把数据锁上。在问题出现之前阻止问题的发生，这种方法很安全，但是性能有瓶颈，在实际中应用更多的是基于乐观的控制方法—时间戳并发控制。


在时间戳并发控制中，最核心的概念就是事务的时间戳，如果$TS(T_{i}) < TS(T_{j})$，那么时间戳并发控制要确保$T_{i}$在$T_{j}$之前结束，并且两个事务是Serializable的。

其中$TS(T_{i})$表示事务i的时间戳，关于时间戳的选取，有三种方法

* 系统时钟：使用系统时间，可能有跳时现象
* 逻辑计数器：从0开始加，在分布式系统上难以同步
* 混合方法：将上面两种方法混合

## Basic Timestamp Ordering

首先介绍基础的时间戳并发控制方法，与二阶段锁不同，Basic T/O不给行数据上锁，而是更改两个时间戳：

* 读时间戳R-TS(X)
* 写时间戳W-TS(X)

在操作时，DBMS检查数据的时间戳，判断操作能否进行。其模式有以下几种

**读操作**

如果读取了一个来自未来的数据X（写时间戳大于该事务），则abort。反之，允许事务读取X，将读取的值复制在事务的本地空间中，如果此时事务的时间戳大于X的读时间戳，则将X的读时间戳更新为事务时间戳。

**写操作**

如果写一个来自未来的数据X（读或写时间戳大于该事务），则abort。反之，允许事务写X，将值写入后复制在事务的本地空间中，更新数据的写时间戳。

托马斯写规则：如果一个事务A在写入X后，X被另一个事务B写入，此时A不用abort，因为相当于A没有写。即如果写一个来自未来的数据X（写时间戳大于该事务），不进行abort，而是不写入继续执行下去。

**优缺点**

- 如果事务abort后时间戳不更新，非常长的事务可能会饥饿，因为长事务冲突的概率更大
- 如果老事务abort的话，相关的新事务不可恢复
- 因为每次读写时都会复制数据，这可能会有性能问题


## Optimistic Concurrency Control

乐观并发控制（OCC）是另一种乐观并发控制协议，它也使用时间戳来验证事务。在OCC中，DBMS为每个事务创建一个本地空间，与Basoc T/O类似，读取的任何对象都会复制到工作区，写入的任何对象都会复制到工作区并在那里进行修改。任何其他事务都无法读取另一个事务在其私有工作区中所做的更改。

在OCC中，对象X只有写时间戳，将事务执行分为三个阶段：

* 读阶段：正常的读数据，复制到本地空间中
* 验证阶段

DBMS在事务进入验证阶段时分配时间戳。为了确保只允许串行调度，DBMS检查$T_{i}$与其他事务的RW和WW冲突，并确保所有冲突都是单向的（从较旧的事务到较新的事务）。DBMS检查提交事务与所有其他正在运行的事务的时间戳顺序。尚未进入验证阶段的交易被分配一个时间戳$\infty$。

![](http://pic.netpunk.top/images/2022/07/01/20220701213240.png)

* 写阶段

如果验证成功，DBMS将本地空间的更改写入到数据库。否则事务abort

**适用场景**

- 十分适合只读事务的并发控制，比二阶段锁快很多
- 当数据库数据量大且访问均匀的情况下，OCC适合很适合

**问题**

* 复制数据的开销大
* 验证算法可能很复杂，造成性能开销
* 不像二阶段锁，OCC不能在事务中途回滚，因此回滚浪费大

## Isolation Levels

Serializability是一个很有用的概念，事务之间如果能够达成Serializability，开发者就能够不用管事务的并发问题，专注于逻辑。但Serializability同样会带来沉重的性能负担，从上文中为了保证Serializability所设置的机制复杂程度就可以看出来。为了贴合实际所需，研究者提出了更弱的Serializability，与Serializability一同组成了Isolation levels。

> 隔离级别表示被隔离事务向其它事务的暴露程度

在事务并发执行过程中，可能会经历的异常状况有三种：

* 脏读：事务读取未提交的数据
* 不可重复读：事务两次读取数据结果不同
* 幻读：插入或删除操作的前后，扫描相同的数据得到的结果不同，防止幻读的方式有很多，如重扫描、谓词锁、索引锁等

隔离级别与异常状况的对应关系如下：

![](http://pic.netpunk.top/images/2022/07/02/20220702100747.png)

其中，越高级的隔离级别会使用的并发控制机制越多，相对应的性能也就越差：

* SERIALIZABLE：应用所有的锁，包括强二阶段锁和索引锁（防止幻读）
* REPEATABLE READS：和上面类似，但是没有索引锁
* READ COMMITTED：和上面类似，但是共享锁会被立即释放。
* READ UNCOMMITTED：和上面类似，但是没有共享锁，即允许脏读。

事实上，很少有数据库的设计者觉得并发控制一定要到达SERIALIZABLE的程度，这没有必要，可参考下面这张数据库并发控制等级图：

![](http://pic.netpunk.top/images/2022/07/02/20220702103426.png)

可以发现只有少数数据的默认等级是SERIALIZABLE，有的数据库甚至最高等级都没有到达SERIALIZABLE，究其原因是大部分的事务都不会有那么多的并发冲突，如下图所示，Read Committed就能够满足75%以上的要求。

![](http://pic.netpunk.top/images/2022/07/02/20220702103622.png)

另外，在SQL-92标准中，定义了我们能够指定事务的并发控制等级，赋予了我们开发者更大的灵活度。

~~~sql
SET TRANSACTION ISOLATION LEVEL <isolation-level>;
或
BEGIN TRANSACTION ISOLATION LEVEL <isolation-level>;
~~~

此外还有两种并发控制等级

**CURSOR STABILITY**

* 其控制等级介于可重复读和读已提交之间
* 可防止更新丢失异常
* 这是DB2的默认控制等级

**SNAPSHOT ISOLATION**

* 保证事务中的所有读取都能看到事务启动时存在的数据库的一致快照。
* 只有当事务的写入操作与自快照之后进行的任何并发更新不冲突时，事务才会提交。
* 因此对写偏移异常有容忍性

























