MULTI-VERSION CONCURRENCY CONTROL即多版本并发控制，指将数据库的更改当作一个版本，通过时间戳管理版本的并发控制手段，一般MVCC结合2PL、T/O、OCC来一起提供并发控制方案。

## MVCC概述

多版本并发控制（MVCC）是一个比并发控制协议更大的概念。它涉及数据库管理系统设计和实现的各个方面。MVCC是数据库管理系统中使用最广泛的方案。在过去10年中，几乎每一个新的DBMS都使用了它。甚至一些不支持多语句事务的系统（例如NoSQL）也支持它。

通过MVCC，DBMS在数据库中维护单个逻辑对象的多个物理版本。**当事务写入对象时，DBMS会创建该对象的新版本。当事务读取对象时，它会读取事务启动时存在的最新版本。**

> 此处版本不能简单理解成数据的一个备份，后面会讲到为什么

MVCC的基本概念/优点是，写事务不会阻塞写事务，读事务也不会阻塞读事务。这意味着一个事务可以修改对象的同时其他事务可以读取旧版本。

使用MVCC的一个优点是，只读事务可以读取数据库的一致快照，而无需使用任何类型的锁。此外，多版本DBMS可以轻松支持时间旅行查询，这是基于数据库在其他某个时间点的状态的查询（例如，像3小时前那样对数据库执行查询）

在MVCC中，有以下四个设计要点：

* 并发控制方法
* 版本存储
* 垃圾回收
* 索引管理

其中并发控制方法指代之间讲过的方法包括2PL、T/O、OCC。

## 版本存储

DBMS使用元组的指针字段为每个逻辑元组创建一个版本链，它本质上是一个按时间戳排序的版本链表。这允许DBMS查找特定事务在运行时可见的版本。索引总是指向链的“头”，链表头代表最新或最旧的版本。当需要读写版本时，专有线程遍历链，直到找到正确的版本。不同的存储方案决定了每个版本的存储位置/内容。

**方案一：Append-Only**

逻辑元组的所有物理版本都存储在相同的表空间中。版本在表中混合在一起，每次更新只是将元组的新版本附加到表中，并更新版本链。链可以被排序为从最旧到最新（Old to New），这需要在查找时进行链遍历，或者从最新到最旧（New to Old），这需要为每个新版本更新索引指针。

![](http://pic.netpunk.space/images/2022/07/02/20220702193021.png)

**方案二：Time-Travel Storage**

DBMS维护一个称为时间旅行表的**单独表**，该表存储元组的旧版本。每次更新时，DBMS都会将元组的旧版本复制到时间旅行表中，并用新数据覆盖主表中的元组。主表中的元组指针指向时间旅行表中的过去版本。

![](http://pic.netpunk.space/images/2022/07/02/20220702193242.png)

**方案三：Delta Storage**

与时间旅行存储类似，DBMS不是存储整个过去的元组，而是只存储增量，或元组之间的变化，即所谓的增量存储段。然后，事务可以通过迭代Delta来重新创建旧版本。这导致写入速度比时间旅行存储快，且更节省存储空间，但读取速度较慢。

![](http://pic.netpunk.space/images/2022/07/02/20220702193406.png)

## 垃圾回收

DBMS需要随着时间的推移从数据库中删除可回收的物理版本。如果没有运行中的事务可以“看到”该版本，或者该版本是由已经中止的事务创建的，则该版本是可回收的。从操作粒度上可以分成两种垃圾回收方式：

**Tuple-level GC**

在元组级垃圾收集中，DBMS通过直接检查元组来查找旧版本。有两种方法可以实现这一点：

* 定时回收

独立专有线程定期扫描表并查找可回收版本，这适用于任何版本的存储方案。

一个简单的优化是维护“脏页位图”，它跟踪自上次扫描以来修改的页面。这允许线程跳过未更改的页面。

![](http://pic.netpunk.space/images/2022/07/02/20220702195431.png)

* 合作清理

独立专有线程在需要遍历版本链时识别可回收的版本。这仅适用于Old to New型链。

![](http://pic.netpunk.space/images/2022/07/03/20220703111414.png)

**Transaction-level GC**

在事务级垃圾收集下，每个事务负责跟踪自己的旧版本，因此DBMS不必扫描元组。每个事务都维护自己的读/写集。当事务完成时，垃圾收集器可以使用它来标识要回收的元组。DBMS确定由完成的事务创建的所有版本何时不再可见。

![](http://pic.netpunk.space/images/2022/07/03/20220703111632.png)

## 索引管理

在MVCC中，关系表的所有主键primary key索引始终指向版本链头。DBMS更新主键索引的频率取决于更新元组时系统是否创建新版本。如果事务更新主键属性，则这在操作上会被视为先删除后插入。

二级索引的管理更为复杂，处理它们有两种方法：

**Logical Pointer**

DBMS对每个元组使用一个不变的固定标识符。这需要一个额外的间接层，将逻辑id映射到元组的物理位置。然后，对元组的更新可以只更新间接层中的映射。

![](http://pic.netpunk.space/images/2022/07/03/20220703112810.png)

**Physical Pointer**

DBMS使用版本链头的物理地址，因为二级索引可能有多个，如果它们都指向版本链头的话，此时版本链头更新，所有索引都要跟着更新。

![](http://pic.netpunk.space/images/2022/07/03/20220703112541.png)





















