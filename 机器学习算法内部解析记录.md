### 尝试

* 改学习率(✔)
* 迭代次数(1,2,3)
* 隐藏层个数和层数(1,2,3)
* 用流函数
* 不随机，全部训练
* 为反向传播权值冲量项(×)
* 对特征进行标准化处理
* 将训练模型与测试模型分开(×)
* **对input归一化**(✔)
* 尝试不同训练集比例
* 如何判断过拟合

在ann = ANNClassifier(hidden_layer_sizes=(50,), eta=0.0001, max_iter=100000, tol=0.00001)为基础上进行改进

* 训练集比例：貌似没有太大变化
* 学习率：
* 

matplotlib

* 不同模型的当前最佳比较
* 不同模型各自不同训练集比例

### 问题

* 误差意味什么？(✔)
* 隐藏层意味着什么？(✔)
* 最后一张照片为什么用不上?
* 怎样预测准确率?(✔)
* 代码执行的顺序到底是什么？(✔)
* 如何保存训练好的模型？(✔)
* 各种专业术语是什么？
* 模型保存是什么原理？(✔)
* 误差为什么可以怎么算？(✔)
* 不知道是样本的原因还是算法的原因，误差数据会有明显波动？
* 如何实现批量梯度下降找到全局最小解？

# TMD

* 类的构造函数，用于初始化类成员等，只能用__init__ ，不能换其他名字

* 在Python的类中有很多方法的名字有特殊的重要意义。__init__方法的意义：__init__方法在类的一个对象被建立时，马上运行。这个方法可以用来对你的对象做一些你希望的初始化。 

* 无论采用哪种方法，self 所表示的都是实际调用该方法的对象。 

* numpy . matmul 函数返回两个数组的矩阵乘积。当两个数组都是二维数组的时候，就是数学上的两个矩阵的乘积 。思考一二三维数组相乘是什么样子。

* 指定沿着哪条轴求和。默认情况下axis=None，此时计算数组所有元素的和。   **numpy. sum**(a, axis=None,  dtype=None, out=None,  keepdims=) 

* 输出y这个对象的大小，比如y是一个二维的矩阵，那么他就会返回一个两个元素的列表或者元组表示矩阵的大小

* np. random. rand()  （1）生成单个随机数。  （2）生成指定结构的随机数组。  **将其填充在一个均匀分布的随机样本\**[0, 1)中\**** 

* 在浏览器看元组操作

* zip() 函数返回 zip 对象，它是元组的迭代器，其中每个传递的迭代器中的第一项配对在一起，然后每个传递的迭代器中的第二项配对在一起，依此类推。 

* Python数字`shuffle()`方法将列表的项目随机化到位，返回重新排列的列表。 

* 用zip可以配合for in实现多个值同时迭代 

* None有哪些常用用法？这里有两个None类型的用法用于迭代

* np. argmax表示沿轴索引最大值的**索引**

* zeros创建一个指定形状的全0矩阵，zeros_like返回一个和输入矩阵一样形状的全0矩阵

* 数组的切片是会切到底的

* 梯度下降的迭代次数：所有的图片都训练500次

* __name__ 是当前模块名，当模块被直接运行时模块名为 __main__ 。这句话的意思就是，当模块被直接运行时，以下代码块将被运行，当模块是被导入时，代码块不被运行。 

* all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False 

* 当我们训练一个神经网络，我们需要知道这个算法偏差高不高，如果偏差较高，典型的**欠拟合状态**，试着评估训练集或训练数据的性能。如果偏差的确很高，甚至无法拟合训练集，那么你要做的就是选择一个**新的网络**，比如含有**更多隐藏层或者隐藏单元的网络**，或者**花费更多时间来训练网络**，或者尝试更先进的**优化算法** 

* 在内部类的变量可以为外部类的不同实例所共享 

* numpy布尔索引对拆分数据极其有用

* var：表示方差，即各项-均值的平方求和后再除以N ，

  std：表示标准差，是var的平方根。

  cov：协方差 ,与var类似，但是除以(N-1)

* 对于神经网络来说，数据不进行归一化对神经元的初始化、梯度的数值、学习率的数量级选择和代码运行速度都有影响， 最主要的影响就是，每一维的偏导数计算出来数量级会不一致。 

* 堆：堆是一种数据结构，是一颗完全二叉树

![1607247000263](C:\Users\86151\AppData\Roaming\Typora\typora-user-images\1607247000263.png)

*  deque模块是python标准库collections中的一项，它提供了两端都可以操作的序列，这意味着，在序列的前后你都可以执行添加或删除操作。 
*  对ndarry使用列表的切片会有奇怪的效果
*  globe让函数内部可调用外部变量而不用传值

## 总结

* 亮点：同时进行了横向和纵向的对比。使用了两种模型评估指标。对数据进行了大量处理。代码模块化易读易修改。
* 不足：模型稳定性太差，导致数据没什么说服力。代码不够精简，还有许多可改进的地方。评价指标还不够准确。图还不够好看。