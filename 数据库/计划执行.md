我们已经知道了数据库较为底层的结构是怎样的，现在我们来查询运算符在数据库中具体的执行是怎样的。关于这方面的内容我们可以分为三个方面来学习：

* 运算符算法：SQL语句中已定义的算子（聚集、并表等）是怎样执行的
* 查询处理模型：查询是用怎样的方案来执行的
* 执行架构：查询的执行在内存中是怎样架构的

首先我们来看执行计划，顾名思义，执行计划就是描述SQL语句在数据库中是如何扫描表、如何使用索引的过程。

<img src="http://1.14.100.228:8002/images/2022/03/17/20220317171856.png" style="zoom:80%;" />

我们研究面向硬盘的数据库，因此不能假设操作的中间结果能够全部装入内存中。所以我们要依赖缓存池和硬盘的配合来执行**运算符算法**。

## 计划算法

### 排序

因为表中的元组在关系模型下没有特定的顺序。而排序（可能）用于ORDER BY、GROUP BY、JOIN和DISTINCT运算符。如果SQL语句里面显式的指名了要使用这些运算符，就要进行排序。

如果需要排序的数据适合内存，那么DBMS可以使用标准的排序算法（例如快速排序）。如果数据不合适，那么DBMS需要使用能够根据需要溢出到磁盘的外部排序，并且更适合顺序而不是随机I/O。

用于大型数据的排序算法是**外部归并排序**，它是一种分而治之的排序算法，将数据集拆分为单独的块，然后对它们进行单独排序。外部归并排序的排序数据是Key-Value对，其中key是要排序的数据，value是要排序数据所在tuple的其它数据。关于value，有两种呈现方式，称为**早物化**和**晚物化**，早物化表示value就是元组数据，随key一起排序，晚物化表示value是元组数据的标识，之后再转化为元组数据。

<img src="http://1.14.100.228:8002/images/2022/03/17/20220317195037.png" style="zoom:80%;" />

我们以最基本的二路归并排序来讲解外部归并排序的具体流程，该算法在排序阶段读取每个页面，对其进行排序，然后将排序后的版本写回磁盘。它从磁盘读取两个排序的页面，并将它们合并到第三个缓冲页面中。每当第三页填满时，它就会被写回磁盘，并替换为一个空页。

<img src="http://1.14.100.228:8002/images/2022/03/17/20220317195219.png" style="zoom:80%;" />

但是实际上内存中不可能只能容下3个块，所以会有N路外部归并排序，其过程如下图所示

<img src="http://1.14.100.228:8002/images/2022/03/17/20220317201234.png" style="zoom:80%;" />

外部合并排序的一个优化是在后台预取下一次运行，并在系统处理当前运行时将其存储在第二个缓冲区中。这通过持续利用磁盘减少了每一步I/O请求的等待时间。这种优化需要使用多个线程，因为预取应该在当前运行的计算进行时进行。

假如系统本身B+树是聚簇的，那么就可以直接用B+树进行排序，但是如果不是聚簇的，那么B+树索引的代价将会远远大于排序的开销。

### 聚集

查询计划中的聚集运算符将一个或多个元组的值折叠为单个标量值。实现聚集有两种方法：排序、散列。

利用排序的原理很好理解，排序天然将重复值聚合到一起，之后的操作就很简单了，在执行排序聚合时，重要的是对查询操作进行排序，以最大限度地提高效率。例如，如果查询需要筛选，最好先执行筛选，然后对筛选后的数据进行排序，以减少需要排序的数据量。

利用哈希的原因是有一些聚集函数是本身不需要排序的，只是排序天然将数据聚集起来了。所以针对这类函数可以用哈希的方法，具体流程为：

1. 先给要聚集的key做一个哈希表，将相同元素放入同一个块里面，并且将冲突元素也放入冲突的块中。如果哈希表比较大，需要将块先存入磁盘中，假如是去重操作，可以提前进行去重，可以缩小块的大小。
2. 之后我们将块中的元素进行重新哈希，因为块中有很多冲突的元素，如果块比较大的话，还可以设置多个哈希函数，确保最后哈希表中相同块元素相同

<img src="http://1.14.100.228:8002/images/2022/03/17/20220317203545.png" style="zoom:80%;" />

有一些聚集操作不只需要操作key，例如AVG，聚集起来算另一列的值。这样可以在第二阶段的时候将值也计算到哈希表里，最后也能得到结果。

































