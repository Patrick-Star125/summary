## 数据库恢复

### 故障恢复

恢复算法是确保数据库一致性、事务原子性和持久性（即使出现故障）的技术。当崩溃（比如断电）发生时，内存中所有尚未提交到磁盘的数据都有丢失的风险。恢复算法用于防止崩溃后信息丢失。

每个恢复算法都由两部分组成：

* 正常事务处理期间的操作，以确保DBMS可以从故障中恢复。
* 当数据库崩溃后，恢复到确保原子性、一致性和持久性的状态的操作。

恢复算法中使用的关键元操作是UNDO和REDO。并非所有算法都同时使用这两种元操作。

* UNDO：消除未完成或中止事务影响的过程
* REDO：恢复已提交事务的影响以实现持久性的过程

### 存储类型

* 易失性存储：断电或程序退出后，数据不会持久，例如DRAN、SRAM

* 非易失性存储：断电或程序存在后，数据仍然存在

* 稳定存储：一种不存在的非易失性存储形式，可在所有可能的故障情况下生存，使用多个存储设备来近似

### 故障类型

由于DBMS根据底层存储设备分为不同的组件，因此DBMS需要处理许多不同类型的故障。其中一些故障是可恢复的，而其他故障是不可恢复的。

* 事务故障：1.逻辑错误 2.内部状态错误
* 系统错误：1.数据库软件错误 2.硬件故障(不包括硬盘故障)
* 磁盘故障：不在考虑范围之内，数据库无法处理这种问题

### 缓存池管理策略

数据库恢复的关键是缓存池的管理方式，或者更具体的，如何将数据从内存（易失性）落到磁盘（非易失性）。

首先DBMS需要保证：

* 一旦DBMS告诉某人它已提交，任何事务的更改都是持久的
* 如果事务中止，则任何部分更改都不会持久

steal policy表示DBMS是否允许未提交的事务覆盖磁盘中对象的最新提交值（事务是否可以将未提交的更改一起写入磁盘）。

force policy规定DBMS是否需要在允许事务提交的时候将事务所做的所有更新落在磁盘上。

强制写入使恢复更容易，因为所有更改都被保留，但会导致运行时性能较差。

最容易实现的缓冲池管理策略称为NO-STEAL+FORCE。在NO-STEAL+FORCE策略中，DBMS永远不必撤消对中止事务的更改，因为这些更改没有写入磁盘。它也不必重做已提交事务的更改，因为所有更改都保证在提交时写入磁盘。

无窃取+强制的限制是，事务需要修改的所有数据都必须适合内存。否则，该事务无法执行，因为不允许DBMS在事务提交之前将脏页写入磁盘。

### shadow page

DBMS维护数据库的两个单独副本，

![](http://1.14.100.228:8002/images/2022/07/05/20220705174521.png)

阴影分页的一个缺点是复制整个页面表的成本很高。实际上，只需要复制树中指向更新叶节点的路径，而不需要复制整个树。此外，阴影分页的提交开销很高。提交要求刷新每个更新的页面、页面表和根。这会导致数据支离破碎，还需要垃圾收集。另一个问题是，它一次只支持一个writer事务或一批事务。

## 数据库日志

**日志文件**

当事务修改页面时，DBMS会在覆盖主版本之前将原始页面复制到单独的日志文件中。重新启动后，如果存在日志文件，则DBMS将其还原以撤消未限制事务中的更改。

### write-ahead log（WAL）

shadow page的缺点很明显，我们需要一个能够批量顺序写入commits的方法，这就是WAL。它的基本理念就是，通过预写日志记录，DBMS在对磁盘页面进行更改之前，将对数据库所做的所有更改记录在日志文件（稳定存储）中。日志包含足够的信息，可以执行必要的撤消和重做操作，以在崩溃后恢复数据库。

**实现**

在事务需要进行写入操作时：

1. 写入前在内存开辟专用缓存存储日志
2. 写入后在内存开辟专用缓存存储数据
3. commit后先将日志写入到磁盘里面
4. 返回用户写入已完成

一条日志至少包含四个信息：事务ID、数据ID、更改前值、更改前后

![](http://1.14.100.228:8002/images/2022/07/07/20220707175337.png)

> 在MySQL中，undo和redo有可能是不同的log（innoDB）

大体上日志有三种存储格式，分别对应不同的commit效率，如下图所示

![](http://1.14.100.228:8002/images/2022/07/07/20220707190833.png)

**检查点**

确定了日志是怎样的，那什么时候日志刷到磁盘上去？

检查点是所有事务的脏数据和日志落盘的时间点，同时是数据库崩溃之后恢复的起点，在这之后，已经commit的事务要REDO，未commit的事务要UNDO

它的作用有三点：1.防止日志无限制增长 2.用于加速恢复 3.作为日志和脏数据的落盘时间点

### Log Sequence Numbers（LSN）

给每条日志加一个全局的序列号，有以下几种特殊的日志号

| Name         | Where      | Definition                                                   |
| ------------ | ---------- | ------------------------------------------------------------ |
| flushedLSN   | 内存       | 记录上一次刷到磁盘上去的log的编号，在该id之前的log已经被刷到磁盘了 |
| pageLSN      | 内存或磁盘 | 记录上一次修改的page的编号，在该id之前的log已经被刷到磁盘了，即最后一个更改页的日志号 |
| recLSN       | 内存或磁盘 | 记录最早一次修改的page的编号，即第一个更改页的日志号         |
| lastLSN      | 内存       | 记录事务i的上一次日志编号                                    |
| MasterRecord | 磁盘       | 记录上一次checkpoint的日志编号                               |
| prevLSN      | 内存或磁盘 | 记录事务i的某一条日志的上一条日志的编号                      |

![](http://1.14.100.228:8002/images/2022/07/08/20220708163758.png)

#### Normal Execution

当事务正常commit之后日志依然会保留，用于回滚，那这些日志什么时候能够清空呢？

当事务中数据都刷盘，即事务彻底结束后，事务会添加一个End log在内存中，系统检测到End log后将该事务的log都清空。

#### Abort Execution

回滚要依赖prevLSN，当回滚发生时，同样是新建日志，不过内容与之前事务日志相反，以达到回滚的目的。

### Fuzzy checkpoint

检查点还存在之前提到的问题，解决方案是对checkpoint时要刷入的数据都加锁，获得临时性的一致性即可。

因此，我们需要两大额外的数据结构：

* ATT：活动事务表

保存正在活跃的事务，包括事务标识符、状态码、lastLSN

* DTT：脏页表

保存脏页，包括脏页页号、recLSN

此时checkpoint不一定要把所有的事务都刷入磁盘，因此我们可以把checkpoint把一个时间点化为一个时间段，也就是模糊的checkpoint。

具体的说，checkpoint分为checkpoint-start和checkpoint-end，当checkpoint开始时，只有checkpoint-start之前未提交的数据和正在运行的事务需要处理，中间的变化都不管。

## ARIES

### Analysis分析

查找上一个checkpoint-start的那个点，分析其上下的日志，最终要找出当崩溃发生时在缓存池中的脏页和活跃的事务。

从上一个checkpoint向后扫描日志：

* 如果发现事务 TXN-END 记录，则说明事务完全结束，该事务无需任何处理
* 如果发现事务 COMMIT 记录，则将其在ATT表中状态改为COMMIT
* 如果发现事务无 COMMIT 记录，则将其在ATT表中状态改为UNDO
* 如果是一个更新日志，就将其page id加入到DPT中

以这种方式得到的ATT和DPT就是当崩溃发生时在缓存池中的活跃的事务和脏页。

![](http://1.14.100.228:8002/images/2022/07/09/20220709162109.png)

### Redo重做

因为日志是顺序遍历的，所以我们无法在一开始就知道那些事务是要重做的。在重做阶段要重做的事务如下：

* 已经commit的事务
* 未commit的事务
* abort的事务
* 清理日志的事务

无需重做的事务：

* 未涉及到脏页，操作数据不在DPT中

重做时的操作：

* 按照日志将操作重做
* 将pageLSN设置为当前重做日志的LSN

将事务从活动事务表ATT里面移除

### Undo回滚

 依然是利用ATT和DPT，不过此时针对的是ATT中标记为Undo的事务，回滚过程如下图所示

![](http://1.14.100.228:8002/images/2022/07/09/20220709165043.png)

和Redo不同，这些Undo操作日志也要写入磁盘中防止二次宕机

### 其它问题

* 不需要担心在Analysis阶段和Redo阶段二次宕机，如果发生这种情况，重新恢复也不会有什么影响
* 还有一种懒恢复的方法，如果没有用户操作涉及到需要恢复的数据，那就不恢复，直到不得不恢复的时候再恢复
* 对于开发者，不要写太长的事务，对执行效率和数据库恢复都不友好

## 总结

ARIES方案有以下几个要点

* 使用基于STEAL和NO-FORCE的WAL日志策略
* 引入模糊检查点提高检查点处理效率
* 重做检查点后commit的事务
* 回滚未commit的事务
* 写入清理日志用于重启的时候保存故障状态
* 引入LSN辅助ARIES各个阶段的操作
  * 用LSN作为链表标识日志顺序关系
  * 标识日志所属状态，反映日志与页的关系



























