# lab4-并发控制

## OVERVIEW

第四个编程项目是在你的数据库系统中实现一个锁管理器，然后用它来支持并发查询的执行。锁管理器负责跟踪发给事务的元组级锁，并支持共享和独占锁，根据隔离级别适当地授予和释放锁。

像以前的项目一样，我们为你提供了包含你需要实现的API的存根类。你不应该修改这些类中预定义的函数的签名。如果你这样做，就会破坏我们用来给你的作业打分的测试代码，而你最终将得不到项目的学分。如果一个类已经包含了某些成员变量，你不应该删除它们。但你可以在这些类中添加私有辅助函数/成员变量，以便正确实现功能。

这个项目的正确性取决于你对以前项目的实现是否正确；我们不会提供解决方案或二进制文件。

## TASK #1 - LOCK MANAGER

为了确保事务操作的正确交错，DBMS将使用一个锁管理器（LM）来控制事务何时被允许访问数据项。LM的基本概念是，它维护一个关于当前由活动事务持有的锁的内部数据结构。事务在被允许访问一个数据项之前，会向LM发出锁请求。LM会将锁授予调用的事务，阻止该事务，或中止该事务。

在你的实现中，整个系统将有一个全局LM（类似于你的缓冲池管理器）。TableHeap和Executor类将使用你的LM来获取元组记录的锁（通过记录ID RID），每当一个事务想要访问/修改一个元组时。

这项任务要求你实现一个元组级LM，它支持三种常见的隔离级别：READ_UNCOMMITED、READ_COMMITTED和REPEATABLE_READ。锁管理器应根据事务的隔离级别授予或释放锁。请参考讲座幻灯片中的细节。

在资源库中，我们为你提供了一个事务上下文句柄（include/concurrency/transaction.h），其中有一个隔离级别属性（即READ_UNCOMMITED、READ_COMMITTED和REPEATABLE_READ）以及关于其获得的锁的信息。LM将需要检查事务的隔离级别，并在锁/解锁请求上公开正确的行为。任何失败的锁操作都应该导致ABORTED事务状态（隐式中止）并抛出一个异常。事务管理器将进一步捕捉这个异常，并回滚由事务执行的写操作。

### REQUIREMENTS AND HINTS

你为这项任务需要修改的唯一文件是LockManager类（concurrency/lock_manager.cpp和concurrency/lock_manager.h）。你将需要实现以下函数。

LockShared(Transaction, RID)。事务txn试图在记录id rid上取得一个共享锁。这应该在等待时被阻止，当被授予时应该返回true。如果交易被回滚（中止），则返回false。
LockExclusive(Transaction, RID)。事务txn试图在记录id rid上取得一个独占锁。这应该在等待时被阻止，当被授予时应该返回true。如果交易被回滚（中止），则返回false。
LockUpgrade(Transaction, RID)。事务txn试图将记录id rid上的共享锁升级为独占锁。这应该在等待时被阻止，并且当被授予时应该返回true。如果交易被回滚（中止），则返回false。如果另一个事务已经在等待升级他们的锁，这也应该中止该事务并返回false。
Unlock(Transaction, RID)。解锁由给定的记录ID标识的、被事务持有的记录。
锁管理器采取的具体锁机制取决于事务的隔离级别。你应该先看看transaction.h和lock_manager.h，熟悉我们提供的API和成员变量。我们还建议你回顾一下隔离级别的概念，因为这些函数的实现应与提出锁定/解锁请求的事务的隔离级别兼容。你可以在lock_manager.h中自由添加任何必要的数据结构。你应该参考教科书中的第15.1-15.2章和讲座中涉及的隔离级别概念，以确保你的实现满足要求。