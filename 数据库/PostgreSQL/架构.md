**简单记一记**

学习路线，三大模块的学习，由浅入深

第一步：架构总体（进程模型、模块分解/src/backend）

第二步：SELECT执行流程（大体）

第三步：重要设计

* 存储结构
* 执行模型
* 内存模型
* 索引管理
* 查询优化（最难的）
* 其它优化的trick

具体的说，目前已知的一定要看的有heap、WAL、

# 进程模型

总体架构

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d7d8dea8cf447a0b5677c5745379ad9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

自定义函数支持：C、SQL、PL/pgSQL/Perl/Python

最主要的两个进程就是守护进程Post-master和服务进程，以及一些辅助进程

守护进程：Postmaster，监听5432端口，生成Postgres进程处理请求

服务进程：Postgres，接受前端过来的查询，然后对数据库进行检索，最后把结果返回（最核心的SELECT实现）

辅助进程：Writer、WalWriter、Archive、Autovacuum

* Writer将适当的时间点把共享内存上的缓存写往磁盘，WAL日志只保存conf.delay间隔的量
* WalWriter把共享内存上的WAL缓存在适当的时间点往磁盘写
* Archive把WAL日志转移到归档日志里。如果保存了基础备份以及归档日志，可以回复数据库到最新的状态
* stats收集好统计表的访问次数，磁盘的访问次数等信息。收集到的信息除了能被autovaccum利用，还可以给其他数据库管理员作为数据库管理的参考信息。
* logger把postgresql的活动状态写到日志信息文件
* vacuum辅助进程

（知识点：父进程、子进程和它们之间的关系）

后台服务进程postgres接收到查询语句后，首先将其传递到查询分析模块，进行此法、语法和语义分析。若是简单的命令（例如建表、创建用户、备份等）则将其分配到功能性命令处理模块；对于复杂的命令（SELECT/INSERT/DELETE/UPDATE）则要为其构建查询树（Query结构体），然后交给查询重写模块。查询重写模块接收到查询树后，按照该查询所设计的规则和视图对查询树进行重写，生成新的查询树。生成路径模块依据重写过程的查询树，考虑关系的访问方式、连接方式和连接顺序等问题，采用动态规划算法或遗传算法，生成最优的表连接路径。最后，由最优路径生成可执行的计划，并将其传递到查询执行模块执行。查询处理各模块说明见下表： 

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f8a7a04caac49f2b8066bc193651d63~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

# 模块分解

最重要的backend源码架构如下

| 目录文件    | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| access      | 各种存储访问方法(在各个子目录下) common(共同函数)、gin (Generalized Inverted Index通用逆向索引)、gist (Generalized Search Tree通用索引)、 hash (哈希索引)、heap (heap的访问方法)、index (通用索引函数)、 n-btree (Btree函数)、transaction(事务处理) |
| bootstrap   | 数据库的初始化处理(initdb的时候)                             |
| catalog     | 系统目录                                                     |
| commands    | 执行非计划查询的SQL命令，如创建表命令等。                    |
| executor    | 执行器，执行来自Optimizer的查询计划。                        |
| foreign     | FDW(Foreign Data Wrapper)处理                                |
| lib         | 共同函数                                                     |
| libpq       | 前端/后端通信处理                                            |
| main        | 主程序模块，它负责将控制权转到Postmaster进程或Postgres进程。 |
| nodes       | 表达式树节点相关的处理函数                                   |
| optimizer   | 优化器，根据查询树创建最优的查询路径和查询计划。             |
| parser      | 编译器，将SQL查询转化为内部查询树。                          |
| port        | 平台兼容性处理相关的函数。                                   |
| postmaster  | 监听用户请求的守护进程，并控制Postgres进程的启动和终止。     |
| replication | streaming replication                                        |
| regex       | 正规表达式库及相关函数，用于支持正规表达式处理。             |
| rewrite     | 规则及视图相关的重写处理                                     |
| snowball    | 全文检索相关（语干处理）                                     |
| storage     | 共享内存、磁盘上的存储、缓存等全部一次/二次记录管理(以下的目录)buffer/(缓存管理)、 file/(文件)、freespace/(Fee Space Map管理) ipc/(进程间通信)、large_object /(大对象的访问函数)、lmgr/(锁管理)、page/(页面访问相关函数)、 smgr/(存储管理器) |
| tcop        | Postgres服务进程的主要处理部分，它调用Parser、Optimizer、Executor和Commands中的函数来执行客户端提交的查询 |
| tsearch     | 全文检索                                                     |
| utils       | 各种模块(以下目录) adt/(嵌入的数据类型)、cache/(缓存管理)、 error/(错误处理)、fmgr/(函数管理)、hash/(hash函数)、 init/(数据库初始化、postgres的初期处理)、 mb/(多字节文字处理)、misc/(其他)、mmgr/(内存的管理函数)、 resowner/(查询处理中的数据(buffer pin及表锁)的管理)、sort/(排序处理)、time/(事务的 MVCC 管理) |

大致模块间的关系如下图所示

![](http://1.14.100.228:8002/images/2023/06/22/20230622155814.png)

