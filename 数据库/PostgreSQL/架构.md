**简单记一记**

# 进程模型

总体架构

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d7d8dea8cf447a0b5677c5745379ad9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

自定义函数支持：C、SQL、PL/pgSQL/Perl/Python

最主要的两个进程就是守护进程Post-master和服务进程，以及一些辅助进程

守护进程：Postmaster，监听5432端口，生成Postgres进程处理请求

服务进程：Postgres，接受前端过来的查询，然后对数据库进行检索，最后把结果返回（最核心的SELECT实现）

辅助进程：Writer、WalWriter、Archive、Autovacuum

* Writer将适当的时间点把共享内存上的缓存写往磁盘，WAL日志只保存conf.delay间隔的量
* WalWriter把共享内存上的WAL缓存在适当的时间点往磁盘写
* Archive把WAL日志转移到归档日志里。如果保存了基础备份以及归档日志，可以回复数据库到最新的状态
* stats收集好统计表的访问次数，磁盘的访问次数等信息。收集到的信息除了能被autovaccum利用，还可以给其他数据库管理员作为数据库管理的参考信息。
* logger把postgresql的活动状态写到日志信息文件
* vacuum辅助进程

（知识点：父进程、子进程和它们之间的关系）

后台服务进程postgres接收到查询语句后，首先将其传递到查询分析模块，进行此法、语法和语义分析。若是简单的命令（例如建表、创建用户、备份等）则将其分配到功能性命令处理模块；对于复杂的命令（SELECT/INSERT/DELETE/UPDATE）则要为其构建查询树（Query结构体），然后交给查询重写模块。查询重写模块接收到查询树后，按照该查询所设计的规则和视图对查询树进行重写，生成新的查询树。生成路径模块依据重写过程的查询树，考虑关系的访问方式、连接方式和连接顺序等问题，采用动态规划算法或遗传算法，生成最优的表连接路径。最后，由最优路径生成可执行的计划，并将其传递到查询执行模块执行。查询处理各模块说明见下表： 

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f8a7a04caac49f2b8066bc193651d63~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

