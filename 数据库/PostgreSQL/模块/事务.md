PostgreSQL为开发者提供了一组丰富的工具来管理对数据的并发访问。在内部，数据一致性通过使用一种多版本模型（多版本并发控制，MVCC）来维护。这就意味着每个 SQL 语句看到的都只是一小段时间之前的数据快照（一个数据库版本），而不管底层数据的当前状态。

在MVCC中，对查询数据的锁请求和写入数据的锁请求不冲突，所以读不会阻塞写，而写也从不阻塞读。甚至在通过使用革新的可序列化快照隔离（SSI）级别提供最严格的事务隔离级别时，PostgreSQL也维持这个保证。（从这个意义上讲，MVCC是并发控制的最佳实践）

# 事务ID

1. PostgreSQL中的txid被定义为一个32位的无符号整数，也就是说能记录大约42亿个事务

2. 获取当前事务ID

   > select txid_current();

3. 特殊事务ID

   * txid = 0 表示 Invalid txid，通常作为判断txid的有效性使用；
   * txid = 1 表示 Bootstrap txid，目前情况下，只在intidb的时候，初始化数据库的时候使用
   * txid = 2 表示 Frozen txid，一般是在Vacuum时使用(在后面会提到)。

4. 基本假设：txid小的事务所修改的元组对txid大的事务来说，是可见的，反之则不可见。

# Tuple结构

简单元组的结构图如下：

![img](https://images2018.cnblogs.com/blog/579102/201809/579102-20180903104737666-1258940454.png)

在上图中我们需要了解的和事务相关的结构是HeapTupleHeaderData结构，这个也就是一条元组的“头”部分。

有几个字段需要我们了解下：

- t_xmin中保存的是插入这条元组的事务的txid
- t_xmax中保存的是更新或者删除这条元组的事务的txid。如果这条元组并没有没删除或者更新，那么t_xmax字段被设置为0，即该字段INVALID
- t_cid中保存的是插入这条元组的命令的id。在一个事务中可能会有多个命令，事务中的这些命令会依次被编号(从0开始递增)。对于如下的事务： BEGIN；INSERT ；INSERT END。那么第一个INSERT的t_cid为0，第二个INSERT的t_cid为1.依次类推。
- t_ctid中保存元组的标识符(即tid)。它指向该元组本身或者该元组的新“版本”。因为PostgreSQL对记录的修改不会直接修改tuple中的用户数据，而是重新生成一个tuple，旧的tuple通过t_ctid指向新的tuple。如果一条记录被修改多次，那么该记录会存在多个“版本”。各版本之间通过t_ctid串联，形成一个版本链。通过这个版本链，我们就可以找到最新的版本了。实际的t_ctid是一个二元组(x,y).其中x(从0开始编号)代表元组所在的page，y(从1开始编号)表示在该page的第几个位置上。