# PG日志

日志有几种记录方式，一是记录REDO，二是UNDO，还有一种是REDO/UNDO日志，REDO允许我们重新进行对数据的修改，UNDO允许我们撤销对数据的修改，REDO/UNDO日志是以上两种日志的结合。

除了WAL以外，还有Shadow Pagging的技术，是System R和sqlite所使用到的技术，看上去有点像COW（Copy On Write，写时复制）技术；此外还存在WBL（Write-Behind Logging，结合NVM所产生的技术）等技术出现。

![img](https://pic4.zhimg.com/80/v2-14c863a91b479dc1a2be4253ea807ce7_720w.webp)

在数据库系统的内部，存在一个叫做 日志管理器 的基本组件，当数据库在正常运行的时候，事务管理器将对数据的操作发送到日志管理器中，日志管理器会将日志顺序写入到缓冲区管理器中，缓冲区管理器将日志刷入到磁盘中，事务管理器只有在确认这条事务的最后一条日志被刷入到磁盘后，才会向客户端返回事务提交的信息。

当崩溃发生时，在重启的时候，恢复管理器就会开始工作，它会读取事务的状态，将已经提交的数据重新回放，将已经放弃或者中断的事务进行回滚，将数据库内不一致的数据恢复到一致的状态。在恢复的时候，恢复管理器有一套算法逻辑在其中，决定如何进行回放，大名鼎鼎的ARIES就是这方面的一个算法。

>  ARIES的算法，是IBM提出的一整套关于日志记录和恢复处理的算法，后续的数据库管理系统都多少参考了该算法。

checkpoint技术让数据库恢复时间缩短，防止日志无限制的增长下去

日志所提供的功能不仅于崩溃恢复，它还能提供复制（包括**主备复制**、**外部订阅复制**等）、**主备状态同步**、**按时间点还原**等功能。

**在记录日志时**

- 每个数据页面 (堆或索引) 都标有影响页面的最新XLog记录的LSN
- 在缓冲区管理器能够写出一个脏页面之前，它必须确保XLog已经被刷新到磁盘，至少达到页面的LSN

LSN检查仅存在于共享缓冲区管理器中，不存在于临时表使用的本地缓冲区管理器中，因此，对**临时表**的操作不能被 WAL记录。

> XLog：Transaction log，事务的日志，通常指的是记录时的在内存中的事务日志
>
> WAL：持久化后的Xlog
>
> LSN：Log sequence number，日志序列号，这是WAL日志唯一的、全局的标识
>
> bgwriter：PostgreSQL负责将脏页面刷入磁盘的进程
>
> walwriter：PostgreSQL负责将WAL刷入磁盘的进程

**在崩溃恢复时**

- 从检查点开始，回放WAL日志，如果数据页面的LSN小于WAL记录的LSN，则说明数据页面比较旧，需要进行回放，反之则不需要回放，就会跳过回放过程。

在回放的过程中，checkpointer会持续地做检查点，让数据页面向前更新，这样万一又重启了，能更快地恢复。

# 日志内容

文件存储：存放在路径`/var/lib/postgresql/data/pg_wal`下每个WAL文件大小为#wal_keep_segments（配置），每个WAL日志文件的命名都是16进制的串，这个串和时间线以及LSN紧密相关，每个WAL文件都包含了特定时间线内，从某个LSN开始到某个LSN结束的WAL日志。根据一个特定的LSN，可以知道对应的WAL日志的文件名，以及在文件中所处的位置。

![](http://1.14.100.228:8002/images/2023/07/08/20230708164939.png)

使用pg_waldump工具我们可以看到PostgreSQL的日志，每一条日志可以理解为一次对数据库的操作记录：

```text
rmgr: Standby     len (rec/tot):     42/    42, tx:        699, lsn: 0/410E21B8, prev 0/410E2180, desc: LOCK xid 699 db 13933 rel 221196
rmgr: Heap        len (rec/tot):     59/    59, tx:        699, lsn: 0/410E21E8, prev 0/410E21B8, desc: INSERT off 4, blkref #0: rel 1663/13933/221196 blk 0
rmgr: Transaction len (rec/tot):     38/    38, tx:        699, lsn: 0/410E2228, prev 0/410E21E8, desc: COMMIT 2020-04-17 08:38:04.881890 UTC
```

这是一条id为699的事务所产生的三条日志，做了锁表、插入数据、提交的操作，让我们对照着SQL看一下这条日志是怎么生成的：

```text
postgres=# begin;
BEGIN      --开启一个新的事务，此时不会分配事务ID，也不会生成WAL
postgres=# lock table t;
LOCK TABLE --锁住表t，生成事务ID 699，生成锁表的日志0/410E21B8
					 --锁住了(db:13933, rel:221196)的表（我们后续会聊这条日志如何在热备模式下发挥作用）
postgres=# insert into t select 1; 
INSERT 0 1 --向表t插入一条数据，生产插入数据的日志0/410E21E8
					 --向表(1663,13933,221196)，BlockNumber为0的page，offset为4的tupe的位置，写入了一条数据，该页面的LSN会被更新为这条日志的LSN
postgres=# end;
COMMIT     --提交，生成提交日志0/410E2228（数据库会等待这条日志刷盘再返回给客户端，这是保证持久化的关键，当然得设置同步提交为on）
					 --这条日志包含了事务的提交状态，以及提交的时间（我们后续会聊这个时间如何在时间点还原下发挥作用）
```


在上面产生了三条不同类型的日志，有Standby，Heap，Transaction三种类型，这里的类型指的是资源管理器的类型。在PostgreSQL中，对数据不同的操作被进行了分类，例如对序列号的操作、对BTree索引的操作，每一类操作类型会使用对应的资源管理器进行管理，包括进行记录和回放。

# 记录日志

标准流程如下：

1. 对需要修改的页面进行PIN和LOCK操作
2. START_CRIT_SECTION() 开启临界区，此时不允许任何错误，若发生错误，直接报PANIC错误
3. 将需要的修改应用到页面上
4. 将页面标记为脏，这必须发生在WAL日志插入前
5. 如果该表需要进行插入WAL记录的操作，初始化一条XLOG并插入，然后设置页面的LSN
6. END_CRIT_SECTION() 结束临界区。
7. 对需要修改的页面进行UNPIN和UNLOCK操作

具体的过程看函数`heap_insert()`



如果要深入看的话，后面还有很多内容，现在先鸽了











