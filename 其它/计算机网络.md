我知道重点在于现代计算机网络在如何实现**高速稳定的网络连接**这一思想，但是迫于内容实在太多，所以只能先把概念学个浅层

![](http://pic.netpunk.space/images/2022/09/14/20220914155706.png)

### Web

Web就是一种在客户端和服务端之间进行通信的标准流程，通常来说，Web包含三个部分：

* HTML
* URL
* HTTP

其中HTML的发展到现在已经到HTML5。URL并不复杂，因此不需要变化，而HTTP从制定开始变化就不怎么大，到现在盛行的还是1997年的HTTP/1.1。

HTTP是通用网络基础TCP/IP中众多协议中的一种，其中HTTP使用最广，到现在已经跳出了Web这个框架，被运用到了各种场景里。

### 协议概述

计算机网络协议同我们的语言一样，多种多样。不同计算机通信协议各不相同，字符集也不同，为了所有计算机都能够互相通信。ARPA公司与1977年到1979年推出了统一的协议标准：TCP/IP协议，众多TCP/IP基础协议构成了TCP/IP协议族。

![](http://1.14.100.228:8002/images/2022/04/20/20220420152951.png)

TCP/IP协议族中有很多协议，包括常见的TCP、IP、HTTP、DNS、UDP

![](http://1.14.100.228:8002/images/2022/04/16/20220416114807.png)

不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。因此我们需要通信协议，它决定了：

* 如何探测到通信目标
* 由哪一边先发起通信
* 使用哪种语言进行通信
* 怎样结束通信

等等之类的规则，而协议本身存在各种各样的内容，包括：

* 电缆的规格
* IP地址的选定方法
* 寻找异地用户的方法
* 双方建立通信的顺序
* Web页面显示需要处理的步骤

### TCP/IP体系结构

我们要找到HTTP协议所处的位置，首先要看TCP/IP协议在哪些地方应用。如果按实际使用对这些协议分层的话，可以分为4层，应用层、传输层、网络层和数据链路层。

> 如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。

**应用层：**应用层决定了向用户提供应用服务时通信的活动，比如FTP（FileTransfer Protocol，文件传输协议）、DNS（Domain Name System，
域名系统）、HTTP （Hyper Text Transfer Protocol，超文本传输协议）都处于该层。

**传输层：**传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输，有TCP（Transmission ControlProtocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）两种。

**网络层：**网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。

**数据链路层：**用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。

**总体结构**

简易版

<img src="http://1.14.100.228:8002/images/2022/04/20/20220420142418.png" style="zoom:80%;" />

但是严格来讲计算机网络体系结构的通信协议划分为七层，为了学习方便，层次划分还有TCP/IP四层协议以及TCP/IP五层协议，它们之间有如下对应关系。

![](http://1.14.100.228:8002/images/2022/04/20/20220420211234.png)

肉眼可见的十分复杂，详细的来讲个个层的所有内容估计能学到明年去，但是，如果要稍微展开一些讲，应该从底向上的介绍个个层的功能、特征、重要知识等。

**物理层**

* 激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。
* 该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。
* 两个重要设备
  * 中继器（Repeater，也叫放大器）
  * 集线器

**数据链路层**

* 数据链路层在物理层提供的服务的基础上向网络层提供服务，最基本的，将源自网络层来的数据可靠地传输到相邻节点的目标机网络层（通过增加一个以太网首部）

  * 将数据组合成数据块

    > 数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位

  * 控制帧在物理信道上的传输

    * 处理传输差错
    * 调节发送速率以使与接收方相匹配

  * 在两个网络实体之间提供数据链路通路的建立、维持和释放的管理

  * 总结功能：物理地址寻址、数据的成帧、流量控制、数据的检错、重发

* 重要概念

  * 提供可靠的数据传输链路
  * 基本数据单位为帧
  * 以太网协议
  * 重要的设备：网桥、交换机

**网络层**

* 网络层的目的是实现两个端系统之间的数据透明传送，它提供的服务使传输层不需要了解网络中的数据传输和交换技术。
  * 寻址
  * 路由选择、连接的建立、保持和终止
* IP协议提供不可靠的无连接的传送服务（网络的无状态stateless属性）
  * 无连接数据报传输
  * 数据报路由选择
  * 差错控制
* 和IP协议配套的地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP
* 重要概念
  * 对子网间的数据包进行路由选择
  * 实现拥塞控制、网际互连
  * 基本数据单位为IP数据报
  * IP、ICMP、ARP、RARP
  * 重要的设备：路由器

**传输层**

* 和之前的不一样，传输层是端到端、主机到主机的层次，负责将上层数据分段并提供端到端的、可靠的或不可靠的传输，并且根据通信子网的特性，最佳的利用网络资源，网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的**端口**
  * 数据分段
  * 端到端的差错控制和流量控制
  * 提供建立、维护和取消传输连接的功能
  * 信息传送的协议数据单元称为段或报文
* 重要概念
  * 端到端的、可靠的或不可靠的传输
  * 端到端的差错控制和流量控制
  * TCP协议、UDP协议
  * 重要设备：网关

**会话层、表示层、应用层（或者统称应用层）**

* 会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。
* 表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。
* 应用层为操作系统或网络应用程序提供访问网络服务的接口。
* 重要概念
  * 数据传输基本单位为报文
  * 主要协议：FTP、Talnet（远程登录协议）、DNS、SMTP（邮件传送协议）、POP3（邮局协议）、HTTP

#### 总结

综上所述，TCP/IP 网络通常是由上到下分成 4 层，分别是**应用层，传输层，网络层和网络接口层**。

![](http://pic.netpunk.space/images/2022/09/15/20220915131847.png)

再给大家贴一下每一层的封装格式：

![](http://pic.netpunk.space/images/2022/09/15/20220915131858.png)

网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。

### TCP/IP协议

TCP/IP协议是互联网最基本的协议，通俗而言：

* IP给因特网的每一台联网设备规定一个地址，变相的规定了两个设备之间通信的路径。
  * IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层---TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。
  * IP传输的数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。

* TCP负责发现传输的问题，一有问题就要发出信号，要求重新传输，直到所有数据安全正确的传输到目的地。
  * 通过三次握手建立端到端连接，通讯完成时要拆除连接（由于TCP是面向连接的所以只能用于端到端的通讯）
  * 数据流服务：采用"带**重传**的肯定确认"技术来实现传输的可靠性
  * 滑动窗口：TCP还采用一种称为"滑动窗口"的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。

**三次挥手四次握手**

* 连接建立（挥手）
  * 首先Client端发送连接请求报文
  * Server段接受连接后回复ACK报文，并为这次连接分配资源。
  * Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。
* 连接断开
  * Client端发起中断连接请求，也就是发送FIN报文。并且进入FIN-WAIT-1状态
  * Server端接到FIN报文后，知道Client端没有数据要传过来了，但是防止Server端要传的数据没有发送完成，所以Server端先发送ACK，"告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息"。Client端收到ACK报文，进入FIN-WAIT-2状态，等待Server端的FIN报文
  * 当Server端确定数据已发送完成，则向Client端发送FIN报文，Client端收到FIN报文后，"就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以**重传**。
  * Server端收到ACK后，就知道可以断开连接了。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，此时Client端也可以关闭连接，TCP连接正式关闭。
* 为什么要三次握手？
  * 有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据
  * Cient端实际上只有一次请求，而Server端却有2个响应，甚至是N个响应，而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费
* 为什么要四次挥手
  * 假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。
  * 但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；
  * 故Server端还得终止主动向你发送数据，并等待你的确认。
  * 其实，说白了就是保证双方的一个合约的完整执行

### UPD协议

* UDP是面向无连接的的通讯协议，通讯时不需要接收方确认，属于不可靠的传输，实际应用中要求程序员编程验证是否出错。
  * UDP数据：UDP报头、UDP数据区
    * 头由四个16位长（2字节）字段组成，有四个域，每个域占用2个字节，分别包含
      * 源端口号
      * 目标端口号
      * 数据报长度
      * 校验值
  * 不管数据包的顺序、错误或重发
    * 因此不能用于面向连接的服务
  * 用于那些面向查询---应答的服务，这些服务需要交换的信息量较小。
    * TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。
  * 与TCP的区别
    * TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。

### IP地址

**网络地址：**IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络（或者整个子网），实际上IP细来讲又分为三部分：网络部分(network)子网段部分(subnetwork)和主机部分(host)，

**广播地址：**广播地址通常称为直接广播地址，是为了区分受限广播地址。广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。

**组播地址**

D类地址就是组播地址。

先回忆下A，B，C，D类地址吧：

A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；(**modified @2016.05.31**)

B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255;

C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。

D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）；

E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。

注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。

每一个IP被4个点分成4部分，每一部分有8位，也就是一个IP实际上是一个一共32位的二进制数

然后，这个32位的数根据需要被分为五大类分，由IANA([全球互联网地址指派机构](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%9C%B0%E5%9D%80%E6%8C%87%E6%B4%BE%E6%9C%BA%E6%9E%84))配给大家使用

<img src="http://pic.netpunk.space/images/2022/09/13/20220913152400.png" style="zoom:67%;" />

> 一般来说这五类的用途大致分为：
> A类保留给政府机构（0.0.0.0到127.255.255.255）
> B类分配给中等规模的公司（128.0.0.0到191.255.255.255）
> C类分配给任何需要的人（192.0.0.0到223.255.255.255）
> D类用于组播（224.0.0.0---239.255.255.255）
> E类用于实验（240.0.0.0---247.255.255.255）
> A、B、C三类中IP地址=网络地址+主机地址，而D、E两类不区分网络地址和主机地址
> 特殊说明：
> （1）A类中的 10.X.X.X是私有地址；127.X.X.X是保留地址
> （2）B类中的 172.16.0.0~172.31.255.255是私有地址
> （3）C类中的 192.168.X.X是私有地址



### 子网掩码

子网掩码用于划分子网，并且在划分子网的同时，还能通过它知道主机在子网里面的具体ip的具体地址。

方便管理，不同的子网可以相互隔离，整个互联网就是一个巨大的局域网，ip地址有限，那么通过划分子网，如何再在子网里面分配ip地址给子网的主机，这个时候同一一个ip就可以给一整个子网所共用，就解决了互联网ip不够的问题

子网掩码会把一个IP地址按这个划分成这两部分，计算方法是通过把IP地址变成二进制，子网掩码也转成二进制后，两个二进制数按位做 **与运算。**

比如，一个C类地址，ip: 192.168.0.3 ，子网掩码是：255.255.255.0

第一步先转二进制

```text
ip:   192.168.0.3   >  11000000 10101000 00000000 00000011
网掩码：255.255.255.0 >  11111111 11111111 11111111 00000000
```

然后两个二进制按位做与计算

```text
11000000 10101000 00000000 00000011
&
11111111 11111111 11111111 00000000
=
11000000 10101000 00000000 00000000
```

把这个而结果 : 11000000 10101000 00000000 00000000 每个8位转化回变成: 192.168.0.0

```text
192.168.0.0 这个就是我们的网络段（包括了上面说的网络部分和子网部分）
3 就是我们的主机号（主机在子网络里面的标识）
```

**CIDR（无类别域间路由）/VLSM（可变长子网掩码）**

有一个ip地址`192.168.0.3/24`，24表示这个ip的32位二进制数的前24位是网络标识的前缀，剩下的8位是主机标识，严格来，剩下的8位里面，全部是0是这个网络的标识，全部是1是这个网络的子网内广播地址，其他是这个子网网络的可用地址

```text
192.168.0.3   =>  11000000 10101000 00000000 00000011

网络标识的前缀： 11000000 10101000 00000000 --（前24位）换算位10进制：192.168.0
网络标识: 11000000 10101000 00000000 00000000 --剩下8位全是0，转10进制是：192.168.0.0
广播地址  11000000 10101000 00000000 11111111 --剩下8位全是1，转10进制是：192.168.0.255
```

大家看，这个就很容易理解了，除了网络标识和广播地址这两个特殊地址，剩下8位里面其他二进制数就是其他主机的标识。

实际上，这个192.168.0.3/24 ,前24位全1，就是等于255.255.255.0,这个就是这个网络的子网掩码，而无类别域间路由是基于**可变长子网掩码（VLSM）**来进行任意长度的前缀的分配的，所以这个24也可以变成其他数，如16

```text
192.168.0.3/16
```

只有前16位是网络，后面是地址16标识，换算回来就是

```text
192.168.0.0 是网络标识（后16位二进制全位0）
192.168.255.255这个是域内广播地址（后16位二进制全为1）
```

那么192.168.0.0 - 192.168.255.255 间所有的其他地址就是这个子网的可以容纳的主机地址

所以这个子网的地址数量明显比192.168.0.3/24那个要大多了

那么的子网掩码也很容易计算，就是前面16位全是1后面16位全是0，换算成10进制就是255.255.0.0

更多的CIDR/VLSM例子：

![](http://pic.netpunk.space/images/2022/09/14/20220914154653.png)

子网掩码可以帮助标志两个IP地址是否同属于一个子网，让我们能快速计算可用主机数量

### 网络划分



### ARP/RARP协议

* Address Resolution Protocol即地址解析协议ARP是根据IP地址获取物理地址的一个TCP/IP协议

  * 做法就是主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址。
  * 收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。
  * ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。

* ARP工作流程

  * 根据主机A上的路由表内容，IP确定是用于访问主机B的转发IP地址。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址
  * 如果主机A在ARP缓存中没有找到映射，它将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中
  * 本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求，如果匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。
  * 主机B将包含其MAC地址的ARP回复消息直接发送回主机A。
  * 当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。

  > 本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。

* 逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址

  * 功能：通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答就可以得到自身在局域网中的IP地址

* RARP工作流程

  * 给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；
  * 本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；
  * 如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用，如果不存在，RARP服务器对此不做任何的响应；

### 子网内通信过程

[【网络学习】A-B主机在同一子网和不同子网中的通信过程 ](https://www.cnblogs.com/gtea/p/12801443.html)

**同一子网**

两台主机分别为A和B，A主机中如果使用名称访问B主机必须先使用DNS，将B的名称解析为IP，然后A主机一以自己的IP为源地址，B的IP为目标地址封装IP数据包，同时使用A自己的网卡接口的子网掩码和B的IP进行与运算，如果B和自己在相同网络，则由机载接口直接发送出去。但接口在发送时还需要将IP数据包封装成数据帧，这需要两台主机的MAC地址。如果A知道B的MAC，则直接使用B 的MAC作为数据帧中的目的地址，如果不知道则向网络中发送ARP广播，将B的IP解析为MAC。得到B的MAC地址后完成数据帧的封装，将数据帧用高低不同的**电平值**表示发送到物理线路中就可以了。这是同一子网中A向B的单向通信过程。

**不同子网**

![](http://pic.netpunk.space/images/2022/09/14/20220914171229.png)

总结一下，每次同一子网内主机之间要通信之前，源主机都要查询目标ip是否在自己的mac-ip映射表中，如果不存在就要通过arp协议来寻找目标主机的mac地址，找到目标主机的mac之后，源主机会将目标主机的mac-ip添加到映射表中，然后就可以开始点对点发送数据了。

假设我们有如下的网络拓扑结构：

![](http://pic.netpunk.space/images/2022/09/14/20220914171303.png)

我们要跟目标主机通信，就必须知道目标主机的ip和mac地址。如果源主机与目标主机不属于同一子网，那么目标mac地址为默认网关的mac地址。随后数据被发送到默认网关，发送的方式参考上面同一子网内主机的通信（因为默认网关与源主机必定是在同一个子网中的）。默认网关收到后，将目标mac地址设置为下一跳的路由器的mac地址（找不到下一跳的mac地址就使用arp协议，广播到所有子网设备）。**在这一过程中目标IP和源IP始终不变，只有目的mac地址不断变化。**

为什么要同时使用mac地址和ip地址？

不同的地址作用于不同的层，mac作用于数据链路层，ip作用于网络层；数据包中，“mac地址包在ip地址之外面” ，每当一个数据包被解析时，总是mac地址先被解析到。如果数据包的mac地址跟当前设备的mac地址不符，则直接丢弃，反之会继续向上层发送，这样能够提高效率。所以可以这样理解，ip地址是逻辑地址，它可以计算网络的最短路径，为数据包指明了下一个应该去的设备，将下一个设备的mac地址设为目的mac地址，从而使得该数据包能够被送到那个路由器。

总结起来可以这么理解，ip地址为数据包去向指明了方向，下一个站是哪里；而mac地址有点类似于一个跑腿的，能够将数据包运送到指定的设备。因此，可以看到在整个传输过程中目的ip始终不变，应为它表明了数据包的终点，每次到达一个路由器，都会计算出下一步怎么走最优，一旦找到了下一个目标路由器，则将目的mac设为那个路由器的mac，至于怎么到达，就不是ip地址需要操心的了，而是由数据链路层和物理层负责。

### IP、TCP、DNS

**IP协议**

按层次分，IP（Internet Protocol，网际协议）位于网络层。几乎所有使用网络的系统都会用到IP协议，IP不能和IP地址搞混，IP是一种协议的名称，包括ICMP等。它的作用是把各种数据包发送给对方，确保数据包发送到达了对方需要用到IP地址和MAC（Media Access Control Address）地址。具体的，IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和 MAC地址进行配对。

**ARP协议**

ARP（Access Resolution Protocol）协议是一种解析IP地址得到MAC地址的方法。通过MAC地址，数据包能够在多个物理设备之间转发到达目标设备。

**TCP协议**

按层次分，TCP位于传输层，提供可靠的字节流服务。

字节流服务(（ Byte Stream Service）是指，为了方便传输，将大块数据分制成以报文段（ segment)为单位的数据包进行管理。

可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否送达到对方。

**三次握手**

为了准确无误地将数据送达目标处，TCP协议采用了三次握手( three-way handshaking）策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的**标志( flag )**——SYN ( synchronize)和ACK( acknowledgement )。
发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。

**DNS服务**

DNS ( Domain Name System)服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务。

### NAT协议

* NAT是Network Address Translation网络地址转换协议的缩写，属于接入广域网(WAN)技术。
  * 一种将私有（保留）地址转化为合法IP地址的转换技术。
    * 解决了lP地址不足的问题。
    * 有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。
  * 广泛应用于各种类型Internet接入方式和各种类型的网络中。

**DHCP协议**

* DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议
  * 使用UDP协议工作
  * 主要有两个用途
    * 给内部网络或网络服务供应商自动分配IP地址
    * 给用户或者内部网络管理员作为对所有计算机作中央管理的手段

### HTTP协议详解

我们已经介绍了HTTP相关的一些概念，那么HTTP实际是什么呢？在Web服务这一互联网海洋里面，不同主机之间可以通过HTTP进行资源交流，这里的资源指一切可以标识的东西，文本、图片、视频、或者某种服务。使用HTTP请求访问资源的一端称为客户端，提供资源响应的一端称为服务端。 HTTP协议做到访问资源依靠两点：URL和报文

**URL**

URL是Uniform Resource Locator的缩写，顾名思义，表示整个互联网上任一在线资源的位置。经典的URL如下图所示

![](http://1.14.100.228:8002/images/2022/04/20/20220420200142.png)

**报文**

通过HTTP协议通讯的时候信息的载体就是报文，报文的结构如图所示

![](http://1.14.100.228:8002/images/2022/04/20/20220420200612.png)

报文表示了这次请求（响应）的信息，不同内容表示请求的不同状态和功能，请求可以分为以下几类

GET、POST、PUT、HEAD、DELETE、OPTION、TRACE、CONNECT

分别表示请求的不同功能

![](http://1.14.100.228:8002/images/2022/04/20/20220420201124.png)

还有关于HTTP的一些概念如持久连接、管线化、Cookie等，不是很重要

![](http://pic.netpunk.space/images/2022/09/15/20220915150117.png)

### DNS

通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 `Web` 服务器。

但在发送之前，还有一项工作需要完成，那就是**查询服务器域名对应的 IP 地址**，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。

比如我们打电话的时候，必须要知道对方的电话号码，但由于电话号码难以记忆，所以通常我们会将对方电话号 + 姓名保存在通讯录里。

所以，有一种服务器就专门保存了 `Web` 服务器域名与 `IP` 的对应关系，它就是 `DNS` 服务器。

> 域名的层级关系

DNS 中的域名都是用**句点**来分隔的，比如 `www.server.com`，这里的句点代表了不同层次之间的**界限**。

在域名中，**越靠右**的位置表示其层级**越高**。

毕竟域名是外国人发明，所以思维和中国人相反，比如说一个城市地点的时候，外国喜欢从小到大的方式顺序说起（如 XX 街道 XX 区 XX 市 XX 省），而中国则喜欢从大到小的顺序（如 XX 省 XX 市 XX 区 XX 街道）。

实际上域名最后还有一个点，比如 `www.server.com.`，这个最后的一个点代表根域名。

也就是，`.` 根域是在最顶层，它的下一层就是 `.com` 顶级域，再下面是 `server.com`。

所以域名的层级关系类似一个树状结构：

- 根 DNS 服务器（.）
- 顶级域 DNS 服务器（.com）
- 权威 DNS 服务器（server.com）

![DNS 树状结构](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/5.jpg)

根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。

这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。

因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。

> 域名解析的工作流程

1. 客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。
2. 本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 www.server.com 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。
3. 根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”
4. 本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com 的 IP 地址吗？”
5. 顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。
6. 本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。
7. 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。
8. 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。

至此，我们完成了 DNS 的解析过程。现在总结一下，整个过程我画成了一个图。

![域名解析的工作流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg)

DNS 域名解析的过程蛮有意思的，整个过程就和我们日常生活中找人问路的过程类似，**只指路不带路**。

> 那是不是每次解析域名都要经过那么多的步骤呢？

当然不是了，还有缓存这个东西的嘛。

浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。







































