## 抽象、接口、多态、继承

[Java 抽象类 | 菜鸟教程 (runoob.com)](https://www.runoob.com/java/java-abstraction.html)

abstract

如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。然后该类由子类继承，内部方法也在子类中实现

- 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。
- 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
- 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。
- 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。
- 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

[Java 接口 | 菜鸟教程 (runoob.com)](https://www.runoob.com/java/java-interfaces.html)

interface、implement

接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。

接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。

除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。

接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。

[Java 多态 | 菜鸟教程 (runoob.com)](https://www.runoob.com/java/java-polymorphism.html)

个人理解：多态就是，一个父类定义实现的方法，在继承它的不同子类中具有不同实现，看起来就像同一个方法发生在不同的对象上会产生不同的结果。

多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。

多态的具体作用现在看不出来，以后可能会用到吧

[Java 继承 | 菜鸟教程 (runoob.com)](https://www.runoob.com/java/java-inheritance.html)

extends、implements、super、this、final

继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 **java.lang** 包中，所以不需要 **import**）祖先类。

**怎样继承**

~~~java
class 父类 {
}
 
class 子类 extends 父类 {
}
~~~

<img src="http://1.14.100.228:8002/images/2022/01/14/20220114223240.png" style="zoom:50%;" />

**关键字**

extends：在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。

implements：变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口

super：实现对父类成员的访问，用来引用当前对象的父类

this：指向自己的引用

final：把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写

~~~java
这是一个可以体现所有关键字功能的例子
~~~

**构造器**

子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 **super** 关键字调用父类的构造器并配以适当的参数列表。

如果父类构造器没有参数，则在子类的构造器中不需要使用 **super** 关键字调用父类构造器，系统会自动调用父类的无参构造器。

继承的概念连接起了多个概念，这些特性赋予了java类强大的灵活性

<img src="http://1.14.100.228:8002/images/2022/01/14/20220114223931.png" style="zoom:50%;" />

## Arrays数组

java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。

具有以下功能：

- 给数组赋值：通过 fill 方法。
- 对数组排序：通过 sort 方法,按升序。
- 比较数组：通过 equals 方法比较数组中元素值是否相等。
- 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。

![](http://1.14.100.228:8002/images/2022/01/10/20220110232055.png)

**数组的复制**

[Java复制（拷贝）数组的4种方法：arraycopy()方法、clone() 方法、copyOf()和copyOfRan (biancheng.net)](http://c.biancheng.net/view/924.html)

Java复制（拷贝）数组的一般有4种方法：arraycopy()方法、clone() 方法、copyOf()和copyOfRange()

1. Arrays 类的 copyOf() 方法
2. Arrays 类的 copyOfRange() 方法
3. System 类的 arraycopy() 方法
4. Object 类的 clone() 方法

## String字符串

[Java String 类 | 菜鸟教程 (runoob.com)](https://www.runoob.com/java/java-string.html)

字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。

**创建字符串**

1. 直接创建在公共池中
2. 通过String-new创建在堆上
3. 格式化创建

~~~java
String s1 = "Runoob";               // String 直接创建
String s2 = new String("Runoob");   // String 对象创建
String fs;							//格式化创建
fs = String.format("浮点型变量的值为 " +
                   "%f, 整型变量的值为 " +
                   " %d, 字符串变量的值为 " +
                   " %s", floatVar, intVar, stringVar);
~~~

**注意:**String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了。

如果需要对字符串做很多修改，那么应该选择使用 [StringBuffer & StringBuilder 类](https://www.runoob.com/java/java-stringbuffer.html)。

**索引字符**

String不像Arrays，不能通过[]直接索引，在String中通过charAT()方法用索引访问字符

**连接字符串**

String 类提供了连接两个字符串的方法：

string1.concat(string2);

返回 string2 连接 string1 的新字符串。也可以对字符串常量使用 concat() 方法，如：

```
"我的名字是 ".concat("Runoob");
```

更常用的是使用'+'操作符来连接字符串，如：

```
"Hello," + " runoob" + "!"
```

**方法**

[String (Java SE 11 & JDK 11 ) (runoob.com)](https://www.runoob.com/manual/jdk11api/java.base/java/lang/String.html)

| SN(序号) | 方法描述                                                     |
| :------- | :----------------------------------------------------------- |
| 1        | [char charAt(int index)](https://www.runoob.com/java/java-string-charat.html) 返回指定索引处的 char 值。 |
| 2        | [int compareTo(Object o)](https://www.runoob.com/java/java-string-compareto.html) 把这个字符串和另一个对象比较。 |
| 3        | [int compareTo(String anotherString)](https://www.runoob.com/java/java-string-compareto.html) 按字典顺序比较两个字符串。 |
| 4        | [int compareToIgnoreCase(String str)](https://www.runoob.com/java/java-string-comparetoignorecase.html) 按字典顺序比较两个字符串，不考虑大小写。 |

## ArrayList顺序表

[Java中Array与ArrayList的10个区别 - 云+社区 - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1530730)

在使用上ArrayList就像包装好了一些方法的Array

需要的操作满足以下条件时用ArrayList

- 频繁访问列表中的某一个元素。
- 只需要在列表末尾进行添加和删除元素操作。

```
ArrayList<E> objectName =new ArrayList<>();　 // 初始化
```

- **E**: 泛型数据类型，用于设置 objectName 的数据类型，**只能为引用数据类型**。
- **objectName**: 对象名。

ArrayList 是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。

~~~java
sites.add("Google"); //添加元素到 ArrayList 可以使用 add() 方法:
sites.get(1); //访问 ArrayList 中的元素可以使用 get() 方法
sites.set(2, "Wiki"); //如果要修改 ArrayList 中的元素可以使用 set() 方法
sites.remove(3);  //如果要删除 ArrayList 中的元素可以使用 remove() 方法
sites.size();  //如果要计算 ArrayList 中的元素数量可以使用 size() 方法
Collections.sort(sites);// java.util 包中，提供的 sort() 方法可以对字符或数字列表进行排序

~~~

Java ArrayList 常用方法列表如下：

| 方法                                                         | 描述                                |
| :----------------------------------------------------------- | :---------------------------------- |
| [add()](https://www.runoob.com/java/java-arraylist-add.html) | 将元素插入到指定位置的 arraylist 中 |
| [addAll()](https://www.runoob.com/java/java-arraylist-addall.html) | 添加集合中的所有元素到 arraylist 中 |
| [clear()](https://www.runoob.com/java/java-arraylist-clear.html) | 删除 arraylist 中的所有元素         |
| [clone()](https://www.runoob.com/java/java-arraylist-clone.html) | 复制一份 arraylist                  |
| [contains()](https://www.runoob.com/java/java-arraylist-contains.html) | 判断元素是否在 arraylist            |
| [get()](https://www.runoob.com/java/java-arraylist-get.html) | 通过索引值获取 arraylist 中的元素   |

## LinkedList链表

与 ArrayList 相比，LinkedList 的增加和删除的操作效率更高，而查找和修改的操作效率较低。

需要的操作满足以下条件时用LinkedList

- 你需要通过循环迭代来访问列表中的某些元素？
- 需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。

LinkedList也继承了许多类和接口

<img src="http://1.14.100.228:8002/images/2022/01/13/20220114000705.png" style="zoom: 67%;" />

LinkedList有两种创建方式

```java
LinkedList<E> list = new LinkedList<E>();   // 普通创建方法
LinkedList<E> list = new LinkedList(Collection<? extends E> c); // 使用集合创建链表
```

大部分常用操作LinkedList和ArrayList使用方法差不多，有一些操作使用LinkedList比ArrayList更加高效

~~~java
sites.addFirst("Wiki"); //在列表开头添加元素：
sites.addLast("Wiki"); //在列表结尾添加元素：
sites.removeFirst(); //移除列表第一个元素
sites.removeLast(); //移除列表最后一个元素
~~~

**常用方法**

| 方法                                           | 描述                                                         |
| :--------------------------------------------- | :----------------------------------------------------------- |
| public boolean add(E e)                        | 链表末尾添加元素，返回是否成功，成功为 true，失败为 false。  |
| public void add(int index, E element)          | 向指定位置插入元素。                                         |
| public boolean addAll(Collection c)            | 将一个集合的所有元素添加到链表后面，返回是否成功，成功为 true，失败为 false。 |
| public boolean addAll(int index, Collection c) | 将一个集合的所有元素添加到链表的指定位置后面，返回是否成功，成功为 true，失败为 false。 |

## Queue队列

队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作。

LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。

队列的使用较少，用法也比较简单，这里列举一些queue的常用方法

~~~java
Queue<String> queue = new LinkedList<String>();//创建队列
queue.offer("a");//添加元素
queue.poll();//返回第一个元素，并在队列中删除
queue.element();//返回第一个元素
queue.peek();//返回第一个元素
~~~

## Stack栈

## Deque双端队列

## HashMap哈希映射

HashMap是一个散列表，它存储的内容是键值对(key-value)映射，具有以下特征

1. HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。
2. HashMap 是无序的，即不会记录插入的顺序。
3. HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。
4. HashMap 的 key 与 value 类型可以相同也可以不同，可以是字符串（String）类型的 key 和 value，也可以是整型（Integer）的 key 和字符串（String）类型的 value。
5. HashMap 中的元素实际上是对象，一些常见的基本类型可以使用它的包装类。

**创建**

~~~java
HashMap<Integer, String> Sites = new HashMap<Integer, String>();
~~~

**HashMap方法**

|       方法       |       描述       |
| :--------------: | :--------------: |
|  put(key,value)  |    添加键值对    |
|     get(key)     |   通过键获取值   |
|   remove(key)    |    移除键值对    |
| hashmap.clear()  |  移除所有键值对  |
|  hashmap.size()  | 获取键值对的数量 |
| hashmap.keySet() |    获取键序列    |
| hashmap.values() |    获取值序列    |

## HashSet哈希集合

HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合，具有以下特征

1. HashSet 允许有 null 值。
2. HashSet 是无序的，即不会记录插入的顺序。
3. HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。
4. HashSet 实现了 Set 接口。
5. HashSet 中的元素实际上是对象，一些常见的基本类型可以使用它的包装类。

**创建**

~~~java
HashSet<String> sites = new HashSet<String>();
~~~

|            方法            |       描述       |
| :------------------------: | :--------------: |
|        add(element)        |     添加元素     |
|      remove(element)       |   移除某个元素   |
|      hashset.clear()       |   移除所有元素   |
|       hashmap.size()       |  获取元素的数量  |
| hashmap.containes(element) | 判断元素是否存在 |

**利用for-each迭代**

~~~java
for (String i : sites) {
    System.out.println(i);
}
输出结果如下
Google
Runoob
Zhihu
Taobao
~~~

## HashTable哈希表

[Java Hashtable 类 | 菜鸟教程 (runoob.com)](https://www.runoob.com/java/java-hashtable-class.html)

Java 2 重构的Hashtable实现了Map接口，因此，Hashtable现在集成到了集合框架中。它和HashMap类很相似，但是它支持同步。

像HashMap一样，Hashtable在哈希表中存储键/值对。当使用一个哈希表，要指定用作键的对象，以及要链接到该键的值。

它有四种创建方法，构建方法与构造函数类似

~~~java
HashTable();	//就new HashTable()
HashTable(int size);	//第二个构造函数创建指定大小的哈希表
HashTable(int size, float fillRatio);	//创建了一个指定大小的哈希表，并且通过fillRatio指定填充比例
HashTable(Map m);	//创建了一个以M中元素为初始化元素的哈希表。哈希表的容量被设置为M的两倍。
~~~

Hashtable中除了从Map接口中定义的方法外，还定义了以下方法：

| **序号** | **方法描述**                                                 |
| :------- | :----------------------------------------------------------- |
| 1        | **void clear( )**  将此哈希表清空，使其不包含任何键。        |
| 2        | **Object clone( )** 创建此哈希表的浅表副本。                 |
| 3        | **boolean contains(Object value)**  测试此映射表中是否存在与指定值关联的键。 |
| 4        | **boolean containsKey(Object key)** 测试指定对象是否为此哈希表中的键。 |
| 5        | **boolean containsValue(Object value)** 如果此 Hashtable 将一个或多个键映射到此值，则返回 true。 |
| 6        | **Enumeration elements( )** 返回此哈希表中的值的枚举。       |

更多方法在网站中查询

